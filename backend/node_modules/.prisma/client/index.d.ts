
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Benutzer
 * 
 */
export type Benutzer = $Result.DefaultSelection<Prisma.$BenutzerPayload>
/**
 * Model Rolle
 * 
 */
export type Rolle = $Result.DefaultSelection<Prisma.$RollePayload>
/**
 * Model BenutzerRolle
 * 
 */
export type BenutzerRolle = $Result.DefaultSelection<Prisma.$BenutzerRollePayload>
/**
 * Model Klasse
 * 
 */
export type Klasse = $Result.DefaultSelection<Prisma.$KlassePayload>
/**
 * Model BenutzerKlasse
 * 
 */
export type BenutzerKlasse = $Result.DefaultSelection<Prisma.$BenutzerKlassePayload>
/**
 * Model Fach
 * 
 */
export type Fach = $Result.DefaultSelection<Prisma.$FachPayload>
/**
 * Model BenutzerFach
 * 
 */
export type BenutzerFach = $Result.DefaultSelection<Prisma.$BenutzerFachPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Benutzers
 * const benutzers = await prisma.benutzer.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Benutzers
   * const benutzers = await prisma.benutzer.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.benutzer`: Exposes CRUD operations for the **Benutzer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Benutzers
    * const benutzers = await prisma.benutzer.findMany()
    * ```
    */
  get benutzer(): Prisma.BenutzerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolle`: Exposes CRUD operations for the **Rolle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rolles
    * const rolles = await prisma.rolle.findMany()
    * ```
    */
  get rolle(): Prisma.RolleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.benutzerRolle`: Exposes CRUD operations for the **BenutzerRolle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BenutzerRolles
    * const benutzerRolles = await prisma.benutzerRolle.findMany()
    * ```
    */
  get benutzerRolle(): Prisma.BenutzerRolleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.klasse`: Exposes CRUD operations for the **Klasse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Klasses
    * const klasses = await prisma.klasse.findMany()
    * ```
    */
  get klasse(): Prisma.KlasseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.benutzerKlasse`: Exposes CRUD operations for the **BenutzerKlasse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BenutzerKlasses
    * const benutzerKlasses = await prisma.benutzerKlasse.findMany()
    * ```
    */
  get benutzerKlasse(): Prisma.BenutzerKlasseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fach`: Exposes CRUD operations for the **Fach** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faches
    * const faches = await prisma.fach.findMany()
    * ```
    */
  get fach(): Prisma.FachDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.benutzerFach`: Exposes CRUD operations for the **BenutzerFach** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BenutzerFaches
    * const benutzerFaches = await prisma.benutzerFach.findMany()
    * ```
    */
  get benutzerFach(): Prisma.BenutzerFachDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Benutzer: 'Benutzer',
    Rolle: 'Rolle',
    BenutzerRolle: 'BenutzerRolle',
    Klasse: 'Klasse',
    BenutzerKlasse: 'BenutzerKlasse',
    Fach: 'Fach',
    BenutzerFach: 'BenutzerFach'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "benutzer" | "rolle" | "benutzerRolle" | "klasse" | "benutzerKlasse" | "fach" | "benutzerFach"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Benutzer: {
        payload: Prisma.$BenutzerPayload<ExtArgs>
        fields: Prisma.BenutzerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BenutzerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BenutzerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerPayload>
          }
          findFirst: {
            args: Prisma.BenutzerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BenutzerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerPayload>
          }
          findMany: {
            args: Prisma.BenutzerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerPayload>[]
          }
          create: {
            args: Prisma.BenutzerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerPayload>
          }
          createMany: {
            args: Prisma.BenutzerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BenutzerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerPayload>
          }
          update: {
            args: Prisma.BenutzerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerPayload>
          }
          deleteMany: {
            args: Prisma.BenutzerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BenutzerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BenutzerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerPayload>
          }
          aggregate: {
            args: Prisma.BenutzerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBenutzer>
          }
          groupBy: {
            args: Prisma.BenutzerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BenutzerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BenutzerCountArgs<ExtArgs>
            result: $Utils.Optional<BenutzerCountAggregateOutputType> | number
          }
        }
      }
      Rolle: {
        payload: Prisma.$RollePayload<ExtArgs>
        fields: Prisma.RolleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RollePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RollePayload>
          }
          findFirst: {
            args: Prisma.RolleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RollePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RollePayload>
          }
          findMany: {
            args: Prisma.RolleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RollePayload>[]
          }
          create: {
            args: Prisma.RolleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RollePayload>
          }
          createMany: {
            args: Prisma.RolleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RolleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RollePayload>
          }
          update: {
            args: Prisma.RolleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RollePayload>
          }
          deleteMany: {
            args: Prisma.RolleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RollePayload>
          }
          aggregate: {
            args: Prisma.RolleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolle>
          }
          groupBy: {
            args: Prisma.RolleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolleCountArgs<ExtArgs>
            result: $Utils.Optional<RolleCountAggregateOutputType> | number
          }
        }
      }
      BenutzerRolle: {
        payload: Prisma.$BenutzerRollePayload<ExtArgs>
        fields: Prisma.BenutzerRolleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BenutzerRolleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerRollePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BenutzerRolleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerRollePayload>
          }
          findFirst: {
            args: Prisma.BenutzerRolleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerRollePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BenutzerRolleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerRollePayload>
          }
          findMany: {
            args: Prisma.BenutzerRolleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerRollePayload>[]
          }
          create: {
            args: Prisma.BenutzerRolleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerRollePayload>
          }
          createMany: {
            args: Prisma.BenutzerRolleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BenutzerRolleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerRollePayload>
          }
          update: {
            args: Prisma.BenutzerRolleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerRollePayload>
          }
          deleteMany: {
            args: Prisma.BenutzerRolleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BenutzerRolleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BenutzerRolleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerRollePayload>
          }
          aggregate: {
            args: Prisma.BenutzerRolleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBenutzerRolle>
          }
          groupBy: {
            args: Prisma.BenutzerRolleGroupByArgs<ExtArgs>
            result: $Utils.Optional<BenutzerRolleGroupByOutputType>[]
          }
          count: {
            args: Prisma.BenutzerRolleCountArgs<ExtArgs>
            result: $Utils.Optional<BenutzerRolleCountAggregateOutputType> | number
          }
        }
      }
      Klasse: {
        payload: Prisma.$KlassePayload<ExtArgs>
        fields: Prisma.KlasseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KlasseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KlassePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KlasseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KlassePayload>
          }
          findFirst: {
            args: Prisma.KlasseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KlassePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KlasseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KlassePayload>
          }
          findMany: {
            args: Prisma.KlasseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KlassePayload>[]
          }
          create: {
            args: Prisma.KlasseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KlassePayload>
          }
          createMany: {
            args: Prisma.KlasseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KlasseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KlassePayload>
          }
          update: {
            args: Prisma.KlasseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KlassePayload>
          }
          deleteMany: {
            args: Prisma.KlasseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KlasseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KlasseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KlassePayload>
          }
          aggregate: {
            args: Prisma.KlasseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKlasse>
          }
          groupBy: {
            args: Prisma.KlasseGroupByArgs<ExtArgs>
            result: $Utils.Optional<KlasseGroupByOutputType>[]
          }
          count: {
            args: Prisma.KlasseCountArgs<ExtArgs>
            result: $Utils.Optional<KlasseCountAggregateOutputType> | number
          }
        }
      }
      BenutzerKlasse: {
        payload: Prisma.$BenutzerKlassePayload<ExtArgs>
        fields: Prisma.BenutzerKlasseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BenutzerKlasseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerKlassePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BenutzerKlasseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerKlassePayload>
          }
          findFirst: {
            args: Prisma.BenutzerKlasseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerKlassePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BenutzerKlasseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerKlassePayload>
          }
          findMany: {
            args: Prisma.BenutzerKlasseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerKlassePayload>[]
          }
          create: {
            args: Prisma.BenutzerKlasseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerKlassePayload>
          }
          createMany: {
            args: Prisma.BenutzerKlasseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BenutzerKlasseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerKlassePayload>
          }
          update: {
            args: Prisma.BenutzerKlasseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerKlassePayload>
          }
          deleteMany: {
            args: Prisma.BenutzerKlasseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BenutzerKlasseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BenutzerKlasseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerKlassePayload>
          }
          aggregate: {
            args: Prisma.BenutzerKlasseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBenutzerKlasse>
          }
          groupBy: {
            args: Prisma.BenutzerKlasseGroupByArgs<ExtArgs>
            result: $Utils.Optional<BenutzerKlasseGroupByOutputType>[]
          }
          count: {
            args: Prisma.BenutzerKlasseCountArgs<ExtArgs>
            result: $Utils.Optional<BenutzerKlasseCountAggregateOutputType> | number
          }
        }
      }
      Fach: {
        payload: Prisma.$FachPayload<ExtArgs>
        fields: Prisma.FachFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FachFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FachPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FachFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FachPayload>
          }
          findFirst: {
            args: Prisma.FachFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FachPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FachFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FachPayload>
          }
          findMany: {
            args: Prisma.FachFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FachPayload>[]
          }
          create: {
            args: Prisma.FachCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FachPayload>
          }
          createMany: {
            args: Prisma.FachCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FachDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FachPayload>
          }
          update: {
            args: Prisma.FachUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FachPayload>
          }
          deleteMany: {
            args: Prisma.FachDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FachUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FachUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FachPayload>
          }
          aggregate: {
            args: Prisma.FachAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFach>
          }
          groupBy: {
            args: Prisma.FachGroupByArgs<ExtArgs>
            result: $Utils.Optional<FachGroupByOutputType>[]
          }
          count: {
            args: Prisma.FachCountArgs<ExtArgs>
            result: $Utils.Optional<FachCountAggregateOutputType> | number
          }
        }
      }
      BenutzerFach: {
        payload: Prisma.$BenutzerFachPayload<ExtArgs>
        fields: Prisma.BenutzerFachFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BenutzerFachFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerFachPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BenutzerFachFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerFachPayload>
          }
          findFirst: {
            args: Prisma.BenutzerFachFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerFachPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BenutzerFachFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerFachPayload>
          }
          findMany: {
            args: Prisma.BenutzerFachFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerFachPayload>[]
          }
          create: {
            args: Prisma.BenutzerFachCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerFachPayload>
          }
          createMany: {
            args: Prisma.BenutzerFachCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BenutzerFachDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerFachPayload>
          }
          update: {
            args: Prisma.BenutzerFachUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerFachPayload>
          }
          deleteMany: {
            args: Prisma.BenutzerFachDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BenutzerFachUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BenutzerFachUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenutzerFachPayload>
          }
          aggregate: {
            args: Prisma.BenutzerFachAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBenutzerFach>
          }
          groupBy: {
            args: Prisma.BenutzerFachGroupByArgs<ExtArgs>
            result: $Utils.Optional<BenutzerFachGroupByOutputType>[]
          }
          count: {
            args: Prisma.BenutzerFachCountArgs<ExtArgs>
            result: $Utils.Optional<BenutzerFachCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    benutzer?: BenutzerOmit
    rolle?: RolleOmit
    benutzerRolle?: BenutzerRolleOmit
    klasse?: KlasseOmit
    benutzerKlasse?: BenutzerKlasseOmit
    fach?: FachOmit
    benutzerFach?: BenutzerFachOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BenutzerCountOutputType
   */

  export type BenutzerCountOutputType = {
    benutzer_rollen: number
    benutzer_klassen: number
    benutzer_faecher: number
  }

  export type BenutzerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benutzer_rollen?: boolean | BenutzerCountOutputTypeCountBenutzer_rollenArgs
    benutzer_klassen?: boolean | BenutzerCountOutputTypeCountBenutzer_klassenArgs
    benutzer_faecher?: boolean | BenutzerCountOutputTypeCountBenutzer_faecherArgs
  }

  // Custom InputTypes
  /**
   * BenutzerCountOutputType without action
   */
  export type BenutzerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerCountOutputType
     */
    select?: BenutzerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BenutzerCountOutputType without action
   */
  export type BenutzerCountOutputTypeCountBenutzer_rollenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BenutzerRolleWhereInput
  }

  /**
   * BenutzerCountOutputType without action
   */
  export type BenutzerCountOutputTypeCountBenutzer_klassenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BenutzerKlasseWhereInput
  }

  /**
   * BenutzerCountOutputType without action
   */
  export type BenutzerCountOutputTypeCountBenutzer_faecherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BenutzerFachWhereInput
  }


  /**
   * Count Type RolleCountOutputType
   */

  export type RolleCountOutputType = {
    benutzer_rollen: number
  }

  export type RolleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benutzer_rollen?: boolean | RolleCountOutputTypeCountBenutzer_rollenArgs
  }

  // Custom InputTypes
  /**
   * RolleCountOutputType without action
   */
  export type RolleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolleCountOutputType
     */
    select?: RolleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolleCountOutputType without action
   */
  export type RolleCountOutputTypeCountBenutzer_rollenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BenutzerRolleWhereInput
  }


  /**
   * Count Type KlasseCountOutputType
   */

  export type KlasseCountOutputType = {
    benutzer_klassen: number
  }

  export type KlasseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benutzer_klassen?: boolean | KlasseCountOutputTypeCountBenutzer_klassenArgs
  }

  // Custom InputTypes
  /**
   * KlasseCountOutputType without action
   */
  export type KlasseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KlasseCountOutputType
     */
    select?: KlasseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KlasseCountOutputType without action
   */
  export type KlasseCountOutputTypeCountBenutzer_klassenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BenutzerKlasseWhereInput
  }


  /**
   * Count Type FachCountOutputType
   */

  export type FachCountOutputType = {
    benutzer_faecher: number
  }

  export type FachCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benutzer_faecher?: boolean | FachCountOutputTypeCountBenutzer_faecherArgs
  }

  // Custom InputTypes
  /**
   * FachCountOutputType without action
   */
  export type FachCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FachCountOutputType
     */
    select?: FachCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FachCountOutputType without action
   */
  export type FachCountOutputTypeCountBenutzer_faecherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BenutzerFachWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Benutzer
   */

  export type AggregateBenutzer = {
    _count: BenutzerCountAggregateOutputType | null
    _avg: BenutzerAvgAggregateOutputType | null
    _sum: BenutzerSumAggregateOutputType | null
    _min: BenutzerMinAggregateOutputType | null
    _max: BenutzerMaxAggregateOutputType | null
  }

  export type BenutzerAvgAggregateOutputType = {
    id: number | null
  }

  export type BenutzerSumAggregateOutputType = {
    id: number | null
  }

  export type BenutzerMinAggregateOutputType = {
    id: number | null
    vorname: string | null
    nachname: string | null
    email: string | null
    passwort_hash: string | null
    erstellt_am: Date | null
    aktiv: boolean | null
  }

  export type BenutzerMaxAggregateOutputType = {
    id: number | null
    vorname: string | null
    nachname: string | null
    email: string | null
    passwort_hash: string | null
    erstellt_am: Date | null
    aktiv: boolean | null
  }

  export type BenutzerCountAggregateOutputType = {
    id: number
    vorname: number
    nachname: number
    email: number
    passwort_hash: number
    erstellt_am: number
    aktiv: number
    _all: number
  }


  export type BenutzerAvgAggregateInputType = {
    id?: true
  }

  export type BenutzerSumAggregateInputType = {
    id?: true
  }

  export type BenutzerMinAggregateInputType = {
    id?: true
    vorname?: true
    nachname?: true
    email?: true
    passwort_hash?: true
    erstellt_am?: true
    aktiv?: true
  }

  export type BenutzerMaxAggregateInputType = {
    id?: true
    vorname?: true
    nachname?: true
    email?: true
    passwort_hash?: true
    erstellt_am?: true
    aktiv?: true
  }

  export type BenutzerCountAggregateInputType = {
    id?: true
    vorname?: true
    nachname?: true
    email?: true
    passwort_hash?: true
    erstellt_am?: true
    aktiv?: true
    _all?: true
  }

  export type BenutzerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Benutzer to aggregate.
     */
    where?: BenutzerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Benutzers to fetch.
     */
    orderBy?: BenutzerOrderByWithRelationInput | BenutzerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BenutzerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Benutzers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Benutzers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Benutzers
    **/
    _count?: true | BenutzerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BenutzerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BenutzerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BenutzerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BenutzerMaxAggregateInputType
  }

  export type GetBenutzerAggregateType<T extends BenutzerAggregateArgs> = {
        [P in keyof T & keyof AggregateBenutzer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBenutzer[P]>
      : GetScalarType<T[P], AggregateBenutzer[P]>
  }




  export type BenutzerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BenutzerWhereInput
    orderBy?: BenutzerOrderByWithAggregationInput | BenutzerOrderByWithAggregationInput[]
    by: BenutzerScalarFieldEnum[] | BenutzerScalarFieldEnum
    having?: BenutzerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BenutzerCountAggregateInputType | true
    _avg?: BenutzerAvgAggregateInputType
    _sum?: BenutzerSumAggregateInputType
    _min?: BenutzerMinAggregateInputType
    _max?: BenutzerMaxAggregateInputType
  }

  export type BenutzerGroupByOutputType = {
    id: number
    vorname: string
    nachname: string
    email: string
    passwort_hash: string
    erstellt_am: Date
    aktiv: boolean
    _count: BenutzerCountAggregateOutputType | null
    _avg: BenutzerAvgAggregateOutputType | null
    _sum: BenutzerSumAggregateOutputType | null
    _min: BenutzerMinAggregateOutputType | null
    _max: BenutzerMaxAggregateOutputType | null
  }

  type GetBenutzerGroupByPayload<T extends BenutzerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BenutzerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BenutzerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BenutzerGroupByOutputType[P]>
            : GetScalarType<T[P], BenutzerGroupByOutputType[P]>
        }
      >
    >


  export type BenutzerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vorname?: boolean
    nachname?: boolean
    email?: boolean
    passwort_hash?: boolean
    erstellt_am?: boolean
    aktiv?: boolean
    benutzer_rollen?: boolean | Benutzer$benutzer_rollenArgs<ExtArgs>
    benutzer_klassen?: boolean | Benutzer$benutzer_klassenArgs<ExtArgs>
    benutzer_faecher?: boolean | Benutzer$benutzer_faecherArgs<ExtArgs>
    _count?: boolean | BenutzerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["benutzer"]>



  export type BenutzerSelectScalar = {
    id?: boolean
    vorname?: boolean
    nachname?: boolean
    email?: boolean
    passwort_hash?: boolean
    erstellt_am?: boolean
    aktiv?: boolean
  }

  export type BenutzerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vorname" | "nachname" | "email" | "passwort_hash" | "erstellt_am" | "aktiv", ExtArgs["result"]["benutzer"]>
  export type BenutzerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benutzer_rollen?: boolean | Benutzer$benutzer_rollenArgs<ExtArgs>
    benutzer_klassen?: boolean | Benutzer$benutzer_klassenArgs<ExtArgs>
    benutzer_faecher?: boolean | Benutzer$benutzer_faecherArgs<ExtArgs>
    _count?: boolean | BenutzerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BenutzerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Benutzer"
    objects: {
      benutzer_rollen: Prisma.$BenutzerRollePayload<ExtArgs>[]
      benutzer_klassen: Prisma.$BenutzerKlassePayload<ExtArgs>[]
      benutzer_faecher: Prisma.$BenutzerFachPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      vorname: string
      nachname: string
      email: string
      passwort_hash: string
      erstellt_am: Date
      aktiv: boolean
    }, ExtArgs["result"]["benutzer"]>
    composites: {}
  }

  type BenutzerGetPayload<S extends boolean | null | undefined | BenutzerDefaultArgs> = $Result.GetResult<Prisma.$BenutzerPayload, S>

  type BenutzerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BenutzerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BenutzerCountAggregateInputType | true
    }

  export interface BenutzerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Benutzer'], meta: { name: 'Benutzer' } }
    /**
     * Find zero or one Benutzer that matches the filter.
     * @param {BenutzerFindUniqueArgs} args - Arguments to find a Benutzer
     * @example
     * // Get one Benutzer
     * const benutzer = await prisma.benutzer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BenutzerFindUniqueArgs>(args: SelectSubset<T, BenutzerFindUniqueArgs<ExtArgs>>): Prisma__BenutzerClient<$Result.GetResult<Prisma.$BenutzerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Benutzer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BenutzerFindUniqueOrThrowArgs} args - Arguments to find a Benutzer
     * @example
     * // Get one Benutzer
     * const benutzer = await prisma.benutzer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BenutzerFindUniqueOrThrowArgs>(args: SelectSubset<T, BenutzerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BenutzerClient<$Result.GetResult<Prisma.$BenutzerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Benutzer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerFindFirstArgs} args - Arguments to find a Benutzer
     * @example
     * // Get one Benutzer
     * const benutzer = await prisma.benutzer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BenutzerFindFirstArgs>(args?: SelectSubset<T, BenutzerFindFirstArgs<ExtArgs>>): Prisma__BenutzerClient<$Result.GetResult<Prisma.$BenutzerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Benutzer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerFindFirstOrThrowArgs} args - Arguments to find a Benutzer
     * @example
     * // Get one Benutzer
     * const benutzer = await prisma.benutzer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BenutzerFindFirstOrThrowArgs>(args?: SelectSubset<T, BenutzerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BenutzerClient<$Result.GetResult<Prisma.$BenutzerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Benutzers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Benutzers
     * const benutzers = await prisma.benutzer.findMany()
     * 
     * // Get first 10 Benutzers
     * const benutzers = await prisma.benutzer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const benutzerWithIdOnly = await prisma.benutzer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BenutzerFindManyArgs>(args?: SelectSubset<T, BenutzerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenutzerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Benutzer.
     * @param {BenutzerCreateArgs} args - Arguments to create a Benutzer.
     * @example
     * // Create one Benutzer
     * const Benutzer = await prisma.benutzer.create({
     *   data: {
     *     // ... data to create a Benutzer
     *   }
     * })
     * 
     */
    create<T extends BenutzerCreateArgs>(args: SelectSubset<T, BenutzerCreateArgs<ExtArgs>>): Prisma__BenutzerClient<$Result.GetResult<Prisma.$BenutzerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Benutzers.
     * @param {BenutzerCreateManyArgs} args - Arguments to create many Benutzers.
     * @example
     * // Create many Benutzers
     * const benutzer = await prisma.benutzer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BenutzerCreateManyArgs>(args?: SelectSubset<T, BenutzerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Benutzer.
     * @param {BenutzerDeleteArgs} args - Arguments to delete one Benutzer.
     * @example
     * // Delete one Benutzer
     * const Benutzer = await prisma.benutzer.delete({
     *   where: {
     *     // ... filter to delete one Benutzer
     *   }
     * })
     * 
     */
    delete<T extends BenutzerDeleteArgs>(args: SelectSubset<T, BenutzerDeleteArgs<ExtArgs>>): Prisma__BenutzerClient<$Result.GetResult<Prisma.$BenutzerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Benutzer.
     * @param {BenutzerUpdateArgs} args - Arguments to update one Benutzer.
     * @example
     * // Update one Benutzer
     * const benutzer = await prisma.benutzer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BenutzerUpdateArgs>(args: SelectSubset<T, BenutzerUpdateArgs<ExtArgs>>): Prisma__BenutzerClient<$Result.GetResult<Prisma.$BenutzerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Benutzers.
     * @param {BenutzerDeleteManyArgs} args - Arguments to filter Benutzers to delete.
     * @example
     * // Delete a few Benutzers
     * const { count } = await prisma.benutzer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BenutzerDeleteManyArgs>(args?: SelectSubset<T, BenutzerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Benutzers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Benutzers
     * const benutzer = await prisma.benutzer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BenutzerUpdateManyArgs>(args: SelectSubset<T, BenutzerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Benutzer.
     * @param {BenutzerUpsertArgs} args - Arguments to update or create a Benutzer.
     * @example
     * // Update or create a Benutzer
     * const benutzer = await prisma.benutzer.upsert({
     *   create: {
     *     // ... data to create a Benutzer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Benutzer we want to update
     *   }
     * })
     */
    upsert<T extends BenutzerUpsertArgs>(args: SelectSubset<T, BenutzerUpsertArgs<ExtArgs>>): Prisma__BenutzerClient<$Result.GetResult<Prisma.$BenutzerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Benutzers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerCountArgs} args - Arguments to filter Benutzers to count.
     * @example
     * // Count the number of Benutzers
     * const count = await prisma.benutzer.count({
     *   where: {
     *     // ... the filter for the Benutzers we want to count
     *   }
     * })
    **/
    count<T extends BenutzerCountArgs>(
      args?: Subset<T, BenutzerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BenutzerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Benutzer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BenutzerAggregateArgs>(args: Subset<T, BenutzerAggregateArgs>): Prisma.PrismaPromise<GetBenutzerAggregateType<T>>

    /**
     * Group by Benutzer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BenutzerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BenutzerGroupByArgs['orderBy'] }
        : { orderBy?: BenutzerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BenutzerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBenutzerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Benutzer model
   */
  readonly fields: BenutzerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Benutzer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BenutzerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    benutzer_rollen<T extends Benutzer$benutzer_rollenArgs<ExtArgs> = {}>(args?: Subset<T, Benutzer$benutzer_rollenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenutzerRollePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    benutzer_klassen<T extends Benutzer$benutzer_klassenArgs<ExtArgs> = {}>(args?: Subset<T, Benutzer$benutzer_klassenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenutzerKlassePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    benutzer_faecher<T extends Benutzer$benutzer_faecherArgs<ExtArgs> = {}>(args?: Subset<T, Benutzer$benutzer_faecherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenutzerFachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Benutzer model
   */
  interface BenutzerFieldRefs {
    readonly id: FieldRef<"Benutzer", 'Int'>
    readonly vorname: FieldRef<"Benutzer", 'String'>
    readonly nachname: FieldRef<"Benutzer", 'String'>
    readonly email: FieldRef<"Benutzer", 'String'>
    readonly passwort_hash: FieldRef<"Benutzer", 'String'>
    readonly erstellt_am: FieldRef<"Benutzer", 'DateTime'>
    readonly aktiv: FieldRef<"Benutzer", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Benutzer findUnique
   */
  export type BenutzerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benutzer
     */
    select?: BenutzerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benutzer
     */
    omit?: BenutzerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerInclude<ExtArgs> | null
    /**
     * Filter, which Benutzer to fetch.
     */
    where: BenutzerWhereUniqueInput
  }

  /**
   * Benutzer findUniqueOrThrow
   */
  export type BenutzerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benutzer
     */
    select?: BenutzerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benutzer
     */
    omit?: BenutzerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerInclude<ExtArgs> | null
    /**
     * Filter, which Benutzer to fetch.
     */
    where: BenutzerWhereUniqueInput
  }

  /**
   * Benutzer findFirst
   */
  export type BenutzerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benutzer
     */
    select?: BenutzerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benutzer
     */
    omit?: BenutzerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerInclude<ExtArgs> | null
    /**
     * Filter, which Benutzer to fetch.
     */
    where?: BenutzerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Benutzers to fetch.
     */
    orderBy?: BenutzerOrderByWithRelationInput | BenutzerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Benutzers.
     */
    cursor?: BenutzerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Benutzers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Benutzers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Benutzers.
     */
    distinct?: BenutzerScalarFieldEnum | BenutzerScalarFieldEnum[]
  }

  /**
   * Benutzer findFirstOrThrow
   */
  export type BenutzerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benutzer
     */
    select?: BenutzerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benutzer
     */
    omit?: BenutzerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerInclude<ExtArgs> | null
    /**
     * Filter, which Benutzer to fetch.
     */
    where?: BenutzerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Benutzers to fetch.
     */
    orderBy?: BenutzerOrderByWithRelationInput | BenutzerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Benutzers.
     */
    cursor?: BenutzerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Benutzers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Benutzers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Benutzers.
     */
    distinct?: BenutzerScalarFieldEnum | BenutzerScalarFieldEnum[]
  }

  /**
   * Benutzer findMany
   */
  export type BenutzerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benutzer
     */
    select?: BenutzerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benutzer
     */
    omit?: BenutzerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerInclude<ExtArgs> | null
    /**
     * Filter, which Benutzers to fetch.
     */
    where?: BenutzerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Benutzers to fetch.
     */
    orderBy?: BenutzerOrderByWithRelationInput | BenutzerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Benutzers.
     */
    cursor?: BenutzerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Benutzers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Benutzers.
     */
    skip?: number
    distinct?: BenutzerScalarFieldEnum | BenutzerScalarFieldEnum[]
  }

  /**
   * Benutzer create
   */
  export type BenutzerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benutzer
     */
    select?: BenutzerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benutzer
     */
    omit?: BenutzerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerInclude<ExtArgs> | null
    /**
     * The data needed to create a Benutzer.
     */
    data: XOR<BenutzerCreateInput, BenutzerUncheckedCreateInput>
  }

  /**
   * Benutzer createMany
   */
  export type BenutzerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Benutzers.
     */
    data: BenutzerCreateManyInput | BenutzerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Benutzer update
   */
  export type BenutzerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benutzer
     */
    select?: BenutzerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benutzer
     */
    omit?: BenutzerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerInclude<ExtArgs> | null
    /**
     * The data needed to update a Benutzer.
     */
    data: XOR<BenutzerUpdateInput, BenutzerUncheckedUpdateInput>
    /**
     * Choose, which Benutzer to update.
     */
    where: BenutzerWhereUniqueInput
  }

  /**
   * Benutzer updateMany
   */
  export type BenutzerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Benutzers.
     */
    data: XOR<BenutzerUpdateManyMutationInput, BenutzerUncheckedUpdateManyInput>
    /**
     * Filter which Benutzers to update
     */
    where?: BenutzerWhereInput
    /**
     * Limit how many Benutzers to update.
     */
    limit?: number
  }

  /**
   * Benutzer upsert
   */
  export type BenutzerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benutzer
     */
    select?: BenutzerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benutzer
     */
    omit?: BenutzerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerInclude<ExtArgs> | null
    /**
     * The filter to search for the Benutzer to update in case it exists.
     */
    where: BenutzerWhereUniqueInput
    /**
     * In case the Benutzer found by the `where` argument doesn't exist, create a new Benutzer with this data.
     */
    create: XOR<BenutzerCreateInput, BenutzerUncheckedCreateInput>
    /**
     * In case the Benutzer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BenutzerUpdateInput, BenutzerUncheckedUpdateInput>
  }

  /**
   * Benutzer delete
   */
  export type BenutzerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benutzer
     */
    select?: BenutzerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benutzer
     */
    omit?: BenutzerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerInclude<ExtArgs> | null
    /**
     * Filter which Benutzer to delete.
     */
    where: BenutzerWhereUniqueInput
  }

  /**
   * Benutzer deleteMany
   */
  export type BenutzerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Benutzers to delete
     */
    where?: BenutzerWhereInput
    /**
     * Limit how many Benutzers to delete.
     */
    limit?: number
  }

  /**
   * Benutzer.benutzer_rollen
   */
  export type Benutzer$benutzer_rollenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerRolle
     */
    select?: BenutzerRolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerRolle
     */
    omit?: BenutzerRolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerRolleInclude<ExtArgs> | null
    where?: BenutzerRolleWhereInput
    orderBy?: BenutzerRolleOrderByWithRelationInput | BenutzerRolleOrderByWithRelationInput[]
    cursor?: BenutzerRolleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BenutzerRolleScalarFieldEnum | BenutzerRolleScalarFieldEnum[]
  }

  /**
   * Benutzer.benutzer_klassen
   */
  export type Benutzer$benutzer_klassenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerKlasse
     */
    select?: BenutzerKlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerKlasse
     */
    omit?: BenutzerKlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerKlasseInclude<ExtArgs> | null
    where?: BenutzerKlasseWhereInput
    orderBy?: BenutzerKlasseOrderByWithRelationInput | BenutzerKlasseOrderByWithRelationInput[]
    cursor?: BenutzerKlasseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BenutzerKlasseScalarFieldEnum | BenutzerKlasseScalarFieldEnum[]
  }

  /**
   * Benutzer.benutzer_faecher
   */
  export type Benutzer$benutzer_faecherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerFach
     */
    select?: BenutzerFachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerFach
     */
    omit?: BenutzerFachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerFachInclude<ExtArgs> | null
    where?: BenutzerFachWhereInput
    orderBy?: BenutzerFachOrderByWithRelationInput | BenutzerFachOrderByWithRelationInput[]
    cursor?: BenutzerFachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BenutzerFachScalarFieldEnum | BenutzerFachScalarFieldEnum[]
  }

  /**
   * Benutzer without action
   */
  export type BenutzerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benutzer
     */
    select?: BenutzerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Benutzer
     */
    omit?: BenutzerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerInclude<ExtArgs> | null
  }


  /**
   * Model Rolle
   */

  export type AggregateRolle = {
    _count: RolleCountAggregateOutputType | null
    _avg: RolleAvgAggregateOutputType | null
    _sum: RolleSumAggregateOutputType | null
    _min: RolleMinAggregateOutputType | null
    _max: RolleMaxAggregateOutputType | null
  }

  export type RolleAvgAggregateOutputType = {
    id: number | null
  }

  export type RolleSumAggregateOutputType = {
    id: number | null
  }

  export type RolleMinAggregateOutputType = {
    id: number | null
    bezeichnung: string | null
    beschreibung: string | null
  }

  export type RolleMaxAggregateOutputType = {
    id: number | null
    bezeichnung: string | null
    beschreibung: string | null
  }

  export type RolleCountAggregateOutputType = {
    id: number
    bezeichnung: number
    beschreibung: number
    _all: number
  }


  export type RolleAvgAggregateInputType = {
    id?: true
  }

  export type RolleSumAggregateInputType = {
    id?: true
  }

  export type RolleMinAggregateInputType = {
    id?: true
    bezeichnung?: true
    beschreibung?: true
  }

  export type RolleMaxAggregateInputType = {
    id?: true
    bezeichnung?: true
    beschreibung?: true
  }

  export type RolleCountAggregateInputType = {
    id?: true
    bezeichnung?: true
    beschreibung?: true
    _all?: true
  }

  export type RolleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rolle to aggregate.
     */
    where?: RolleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rolles to fetch.
     */
    orderBy?: RolleOrderByWithRelationInput | RolleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rolles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rolles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rolles
    **/
    _count?: true | RolleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolleMaxAggregateInputType
  }

  export type GetRolleAggregateType<T extends RolleAggregateArgs> = {
        [P in keyof T & keyof AggregateRolle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolle[P]>
      : GetScalarType<T[P], AggregateRolle[P]>
  }




  export type RolleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolleWhereInput
    orderBy?: RolleOrderByWithAggregationInput | RolleOrderByWithAggregationInput[]
    by: RolleScalarFieldEnum[] | RolleScalarFieldEnum
    having?: RolleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolleCountAggregateInputType | true
    _avg?: RolleAvgAggregateInputType
    _sum?: RolleSumAggregateInputType
    _min?: RolleMinAggregateInputType
    _max?: RolleMaxAggregateInputType
  }

  export type RolleGroupByOutputType = {
    id: number
    bezeichnung: string
    beschreibung: string | null
    _count: RolleCountAggregateOutputType | null
    _avg: RolleAvgAggregateOutputType | null
    _sum: RolleSumAggregateOutputType | null
    _min: RolleMinAggregateOutputType | null
    _max: RolleMaxAggregateOutputType | null
  }

  type GetRolleGroupByPayload<T extends RolleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolleGroupByOutputType[P]>
            : GetScalarType<T[P], RolleGroupByOutputType[P]>
        }
      >
    >


  export type RolleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bezeichnung?: boolean
    beschreibung?: boolean
    benutzer_rollen?: boolean | Rolle$benutzer_rollenArgs<ExtArgs>
    _count?: boolean | RolleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolle"]>



  export type RolleSelectScalar = {
    id?: boolean
    bezeichnung?: boolean
    beschreibung?: boolean
  }

  export type RolleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bezeichnung" | "beschreibung", ExtArgs["result"]["rolle"]>
  export type RolleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benutzer_rollen?: boolean | Rolle$benutzer_rollenArgs<ExtArgs>
    _count?: boolean | RolleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RollePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rolle"
    objects: {
      benutzer_rollen: Prisma.$BenutzerRollePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bezeichnung: string
      beschreibung: string | null
    }, ExtArgs["result"]["rolle"]>
    composites: {}
  }

  type RolleGetPayload<S extends boolean | null | undefined | RolleDefaultArgs> = $Result.GetResult<Prisma.$RollePayload, S>

  type RolleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolleCountAggregateInputType | true
    }

  export interface RolleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rolle'], meta: { name: 'Rolle' } }
    /**
     * Find zero or one Rolle that matches the filter.
     * @param {RolleFindUniqueArgs} args - Arguments to find a Rolle
     * @example
     * // Get one Rolle
     * const rolle = await prisma.rolle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolleFindUniqueArgs>(args: SelectSubset<T, RolleFindUniqueArgs<ExtArgs>>): Prisma__RolleClient<$Result.GetResult<Prisma.$RollePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rolle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolleFindUniqueOrThrowArgs} args - Arguments to find a Rolle
     * @example
     * // Get one Rolle
     * const rolle = await prisma.rolle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolleFindUniqueOrThrowArgs>(args: SelectSubset<T, RolleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolleClient<$Result.GetResult<Prisma.$RollePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rolle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolleFindFirstArgs} args - Arguments to find a Rolle
     * @example
     * // Get one Rolle
     * const rolle = await prisma.rolle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolleFindFirstArgs>(args?: SelectSubset<T, RolleFindFirstArgs<ExtArgs>>): Prisma__RolleClient<$Result.GetResult<Prisma.$RollePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rolle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolleFindFirstOrThrowArgs} args - Arguments to find a Rolle
     * @example
     * // Get one Rolle
     * const rolle = await prisma.rolle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolleFindFirstOrThrowArgs>(args?: SelectSubset<T, RolleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolleClient<$Result.GetResult<Prisma.$RollePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rolles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rolles
     * const rolles = await prisma.rolle.findMany()
     * 
     * // Get first 10 Rolles
     * const rolles = await prisma.rolle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolleWithIdOnly = await prisma.rolle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolleFindManyArgs>(args?: SelectSubset<T, RolleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RollePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rolle.
     * @param {RolleCreateArgs} args - Arguments to create a Rolle.
     * @example
     * // Create one Rolle
     * const Rolle = await prisma.rolle.create({
     *   data: {
     *     // ... data to create a Rolle
     *   }
     * })
     * 
     */
    create<T extends RolleCreateArgs>(args: SelectSubset<T, RolleCreateArgs<ExtArgs>>): Prisma__RolleClient<$Result.GetResult<Prisma.$RollePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rolles.
     * @param {RolleCreateManyArgs} args - Arguments to create many Rolles.
     * @example
     * // Create many Rolles
     * const rolle = await prisma.rolle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolleCreateManyArgs>(args?: SelectSubset<T, RolleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rolle.
     * @param {RolleDeleteArgs} args - Arguments to delete one Rolle.
     * @example
     * // Delete one Rolle
     * const Rolle = await prisma.rolle.delete({
     *   where: {
     *     // ... filter to delete one Rolle
     *   }
     * })
     * 
     */
    delete<T extends RolleDeleteArgs>(args: SelectSubset<T, RolleDeleteArgs<ExtArgs>>): Prisma__RolleClient<$Result.GetResult<Prisma.$RollePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rolle.
     * @param {RolleUpdateArgs} args - Arguments to update one Rolle.
     * @example
     * // Update one Rolle
     * const rolle = await prisma.rolle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolleUpdateArgs>(args: SelectSubset<T, RolleUpdateArgs<ExtArgs>>): Prisma__RolleClient<$Result.GetResult<Prisma.$RollePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rolles.
     * @param {RolleDeleteManyArgs} args - Arguments to filter Rolles to delete.
     * @example
     * // Delete a few Rolles
     * const { count } = await prisma.rolle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolleDeleteManyArgs>(args?: SelectSubset<T, RolleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rolles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rolles
     * const rolle = await prisma.rolle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolleUpdateManyArgs>(args: SelectSubset<T, RolleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rolle.
     * @param {RolleUpsertArgs} args - Arguments to update or create a Rolle.
     * @example
     * // Update or create a Rolle
     * const rolle = await prisma.rolle.upsert({
     *   create: {
     *     // ... data to create a Rolle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rolle we want to update
     *   }
     * })
     */
    upsert<T extends RolleUpsertArgs>(args: SelectSubset<T, RolleUpsertArgs<ExtArgs>>): Prisma__RolleClient<$Result.GetResult<Prisma.$RollePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rolles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolleCountArgs} args - Arguments to filter Rolles to count.
     * @example
     * // Count the number of Rolles
     * const count = await prisma.rolle.count({
     *   where: {
     *     // ... the filter for the Rolles we want to count
     *   }
     * })
    **/
    count<T extends RolleCountArgs>(
      args?: Subset<T, RolleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rolle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolleAggregateArgs>(args: Subset<T, RolleAggregateArgs>): Prisma.PrismaPromise<GetRolleAggregateType<T>>

    /**
     * Group by Rolle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolleGroupByArgs['orderBy'] }
        : { orderBy?: RolleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rolle model
   */
  readonly fields: RolleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rolle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    benutzer_rollen<T extends Rolle$benutzer_rollenArgs<ExtArgs> = {}>(args?: Subset<T, Rolle$benutzer_rollenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenutzerRollePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rolle model
   */
  interface RolleFieldRefs {
    readonly id: FieldRef<"Rolle", 'Int'>
    readonly bezeichnung: FieldRef<"Rolle", 'String'>
    readonly beschreibung: FieldRef<"Rolle", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Rolle findUnique
   */
  export type RolleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rolle
     */
    select?: RolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rolle
     */
    omit?: RolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolleInclude<ExtArgs> | null
    /**
     * Filter, which Rolle to fetch.
     */
    where: RolleWhereUniqueInput
  }

  /**
   * Rolle findUniqueOrThrow
   */
  export type RolleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rolle
     */
    select?: RolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rolle
     */
    omit?: RolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolleInclude<ExtArgs> | null
    /**
     * Filter, which Rolle to fetch.
     */
    where: RolleWhereUniqueInput
  }

  /**
   * Rolle findFirst
   */
  export type RolleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rolle
     */
    select?: RolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rolle
     */
    omit?: RolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolleInclude<ExtArgs> | null
    /**
     * Filter, which Rolle to fetch.
     */
    where?: RolleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rolles to fetch.
     */
    orderBy?: RolleOrderByWithRelationInput | RolleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rolles.
     */
    cursor?: RolleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rolles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rolles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rolles.
     */
    distinct?: RolleScalarFieldEnum | RolleScalarFieldEnum[]
  }

  /**
   * Rolle findFirstOrThrow
   */
  export type RolleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rolle
     */
    select?: RolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rolle
     */
    omit?: RolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolleInclude<ExtArgs> | null
    /**
     * Filter, which Rolle to fetch.
     */
    where?: RolleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rolles to fetch.
     */
    orderBy?: RolleOrderByWithRelationInput | RolleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rolles.
     */
    cursor?: RolleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rolles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rolles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rolles.
     */
    distinct?: RolleScalarFieldEnum | RolleScalarFieldEnum[]
  }

  /**
   * Rolle findMany
   */
  export type RolleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rolle
     */
    select?: RolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rolle
     */
    omit?: RolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolleInclude<ExtArgs> | null
    /**
     * Filter, which Rolles to fetch.
     */
    where?: RolleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rolles to fetch.
     */
    orderBy?: RolleOrderByWithRelationInput | RolleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rolles.
     */
    cursor?: RolleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rolles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rolles.
     */
    skip?: number
    distinct?: RolleScalarFieldEnum | RolleScalarFieldEnum[]
  }

  /**
   * Rolle create
   */
  export type RolleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rolle
     */
    select?: RolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rolle
     */
    omit?: RolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolleInclude<ExtArgs> | null
    /**
     * The data needed to create a Rolle.
     */
    data: XOR<RolleCreateInput, RolleUncheckedCreateInput>
  }

  /**
   * Rolle createMany
   */
  export type RolleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rolles.
     */
    data: RolleCreateManyInput | RolleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rolle update
   */
  export type RolleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rolle
     */
    select?: RolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rolle
     */
    omit?: RolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolleInclude<ExtArgs> | null
    /**
     * The data needed to update a Rolle.
     */
    data: XOR<RolleUpdateInput, RolleUncheckedUpdateInput>
    /**
     * Choose, which Rolle to update.
     */
    where: RolleWhereUniqueInput
  }

  /**
   * Rolle updateMany
   */
  export type RolleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rolles.
     */
    data: XOR<RolleUpdateManyMutationInput, RolleUncheckedUpdateManyInput>
    /**
     * Filter which Rolles to update
     */
    where?: RolleWhereInput
    /**
     * Limit how many Rolles to update.
     */
    limit?: number
  }

  /**
   * Rolle upsert
   */
  export type RolleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rolle
     */
    select?: RolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rolle
     */
    omit?: RolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolleInclude<ExtArgs> | null
    /**
     * The filter to search for the Rolle to update in case it exists.
     */
    where: RolleWhereUniqueInput
    /**
     * In case the Rolle found by the `where` argument doesn't exist, create a new Rolle with this data.
     */
    create: XOR<RolleCreateInput, RolleUncheckedCreateInput>
    /**
     * In case the Rolle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolleUpdateInput, RolleUncheckedUpdateInput>
  }

  /**
   * Rolle delete
   */
  export type RolleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rolle
     */
    select?: RolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rolle
     */
    omit?: RolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolleInclude<ExtArgs> | null
    /**
     * Filter which Rolle to delete.
     */
    where: RolleWhereUniqueInput
  }

  /**
   * Rolle deleteMany
   */
  export type RolleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rolles to delete
     */
    where?: RolleWhereInput
    /**
     * Limit how many Rolles to delete.
     */
    limit?: number
  }

  /**
   * Rolle.benutzer_rollen
   */
  export type Rolle$benutzer_rollenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerRolle
     */
    select?: BenutzerRolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerRolle
     */
    omit?: BenutzerRolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerRolleInclude<ExtArgs> | null
    where?: BenutzerRolleWhereInput
    orderBy?: BenutzerRolleOrderByWithRelationInput | BenutzerRolleOrderByWithRelationInput[]
    cursor?: BenutzerRolleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BenutzerRolleScalarFieldEnum | BenutzerRolleScalarFieldEnum[]
  }

  /**
   * Rolle without action
   */
  export type RolleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rolle
     */
    select?: RolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rolle
     */
    omit?: RolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolleInclude<ExtArgs> | null
  }


  /**
   * Model BenutzerRolle
   */

  export type AggregateBenutzerRolle = {
    _count: BenutzerRolleCountAggregateOutputType | null
    _avg: BenutzerRolleAvgAggregateOutputType | null
    _sum: BenutzerRolleSumAggregateOutputType | null
    _min: BenutzerRolleMinAggregateOutputType | null
    _max: BenutzerRolleMaxAggregateOutputType | null
  }

  export type BenutzerRolleAvgAggregateOutputType = {
    id: number | null
    benutzer_id: number | null
    rolle_id: number | null
  }

  export type BenutzerRolleSumAggregateOutputType = {
    id: number | null
    benutzer_id: number | null
    rolle_id: number | null
  }

  export type BenutzerRolleMinAggregateOutputType = {
    id: number | null
    benutzer_id: number | null
    rolle_id: number | null
  }

  export type BenutzerRolleMaxAggregateOutputType = {
    id: number | null
    benutzer_id: number | null
    rolle_id: number | null
  }

  export type BenutzerRolleCountAggregateOutputType = {
    id: number
    benutzer_id: number
    rolle_id: number
    _all: number
  }


  export type BenutzerRolleAvgAggregateInputType = {
    id?: true
    benutzer_id?: true
    rolle_id?: true
  }

  export type BenutzerRolleSumAggregateInputType = {
    id?: true
    benutzer_id?: true
    rolle_id?: true
  }

  export type BenutzerRolleMinAggregateInputType = {
    id?: true
    benutzer_id?: true
    rolle_id?: true
  }

  export type BenutzerRolleMaxAggregateInputType = {
    id?: true
    benutzer_id?: true
    rolle_id?: true
  }

  export type BenutzerRolleCountAggregateInputType = {
    id?: true
    benutzer_id?: true
    rolle_id?: true
    _all?: true
  }

  export type BenutzerRolleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BenutzerRolle to aggregate.
     */
    where?: BenutzerRolleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenutzerRolles to fetch.
     */
    orderBy?: BenutzerRolleOrderByWithRelationInput | BenutzerRolleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BenutzerRolleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenutzerRolles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenutzerRolles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BenutzerRolles
    **/
    _count?: true | BenutzerRolleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BenutzerRolleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BenutzerRolleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BenutzerRolleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BenutzerRolleMaxAggregateInputType
  }

  export type GetBenutzerRolleAggregateType<T extends BenutzerRolleAggregateArgs> = {
        [P in keyof T & keyof AggregateBenutzerRolle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBenutzerRolle[P]>
      : GetScalarType<T[P], AggregateBenutzerRolle[P]>
  }




  export type BenutzerRolleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BenutzerRolleWhereInput
    orderBy?: BenutzerRolleOrderByWithAggregationInput | BenutzerRolleOrderByWithAggregationInput[]
    by: BenutzerRolleScalarFieldEnum[] | BenutzerRolleScalarFieldEnum
    having?: BenutzerRolleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BenutzerRolleCountAggregateInputType | true
    _avg?: BenutzerRolleAvgAggregateInputType
    _sum?: BenutzerRolleSumAggregateInputType
    _min?: BenutzerRolleMinAggregateInputType
    _max?: BenutzerRolleMaxAggregateInputType
  }

  export type BenutzerRolleGroupByOutputType = {
    id: number
    benutzer_id: number
    rolle_id: number
    _count: BenutzerRolleCountAggregateOutputType | null
    _avg: BenutzerRolleAvgAggregateOutputType | null
    _sum: BenutzerRolleSumAggregateOutputType | null
    _min: BenutzerRolleMinAggregateOutputType | null
    _max: BenutzerRolleMaxAggregateOutputType | null
  }

  type GetBenutzerRolleGroupByPayload<T extends BenutzerRolleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BenutzerRolleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BenutzerRolleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BenutzerRolleGroupByOutputType[P]>
            : GetScalarType<T[P], BenutzerRolleGroupByOutputType[P]>
        }
      >
    >


  export type BenutzerRolleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    benutzer_id?: boolean
    rolle_id?: boolean
    benutzer?: boolean | BenutzerDefaultArgs<ExtArgs>
    rolle?: boolean | RolleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["benutzerRolle"]>



  export type BenutzerRolleSelectScalar = {
    id?: boolean
    benutzer_id?: boolean
    rolle_id?: boolean
  }

  export type BenutzerRolleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "benutzer_id" | "rolle_id", ExtArgs["result"]["benutzerRolle"]>
  export type BenutzerRolleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benutzer?: boolean | BenutzerDefaultArgs<ExtArgs>
    rolle?: boolean | RolleDefaultArgs<ExtArgs>
  }

  export type $BenutzerRollePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BenutzerRolle"
    objects: {
      benutzer: Prisma.$BenutzerPayload<ExtArgs>
      rolle: Prisma.$RollePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      benutzer_id: number
      rolle_id: number
    }, ExtArgs["result"]["benutzerRolle"]>
    composites: {}
  }

  type BenutzerRolleGetPayload<S extends boolean | null | undefined | BenutzerRolleDefaultArgs> = $Result.GetResult<Prisma.$BenutzerRollePayload, S>

  type BenutzerRolleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BenutzerRolleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BenutzerRolleCountAggregateInputType | true
    }

  export interface BenutzerRolleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BenutzerRolle'], meta: { name: 'BenutzerRolle' } }
    /**
     * Find zero or one BenutzerRolle that matches the filter.
     * @param {BenutzerRolleFindUniqueArgs} args - Arguments to find a BenutzerRolle
     * @example
     * // Get one BenutzerRolle
     * const benutzerRolle = await prisma.benutzerRolle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BenutzerRolleFindUniqueArgs>(args: SelectSubset<T, BenutzerRolleFindUniqueArgs<ExtArgs>>): Prisma__BenutzerRolleClient<$Result.GetResult<Prisma.$BenutzerRollePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BenutzerRolle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BenutzerRolleFindUniqueOrThrowArgs} args - Arguments to find a BenutzerRolle
     * @example
     * // Get one BenutzerRolle
     * const benutzerRolle = await prisma.benutzerRolle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BenutzerRolleFindUniqueOrThrowArgs>(args: SelectSubset<T, BenutzerRolleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BenutzerRolleClient<$Result.GetResult<Prisma.$BenutzerRollePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BenutzerRolle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerRolleFindFirstArgs} args - Arguments to find a BenutzerRolle
     * @example
     * // Get one BenutzerRolle
     * const benutzerRolle = await prisma.benutzerRolle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BenutzerRolleFindFirstArgs>(args?: SelectSubset<T, BenutzerRolleFindFirstArgs<ExtArgs>>): Prisma__BenutzerRolleClient<$Result.GetResult<Prisma.$BenutzerRollePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BenutzerRolle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerRolleFindFirstOrThrowArgs} args - Arguments to find a BenutzerRolle
     * @example
     * // Get one BenutzerRolle
     * const benutzerRolle = await prisma.benutzerRolle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BenutzerRolleFindFirstOrThrowArgs>(args?: SelectSubset<T, BenutzerRolleFindFirstOrThrowArgs<ExtArgs>>): Prisma__BenutzerRolleClient<$Result.GetResult<Prisma.$BenutzerRollePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BenutzerRolles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerRolleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BenutzerRolles
     * const benutzerRolles = await prisma.benutzerRolle.findMany()
     * 
     * // Get first 10 BenutzerRolles
     * const benutzerRolles = await prisma.benutzerRolle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const benutzerRolleWithIdOnly = await prisma.benutzerRolle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BenutzerRolleFindManyArgs>(args?: SelectSubset<T, BenutzerRolleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenutzerRollePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BenutzerRolle.
     * @param {BenutzerRolleCreateArgs} args - Arguments to create a BenutzerRolle.
     * @example
     * // Create one BenutzerRolle
     * const BenutzerRolle = await prisma.benutzerRolle.create({
     *   data: {
     *     // ... data to create a BenutzerRolle
     *   }
     * })
     * 
     */
    create<T extends BenutzerRolleCreateArgs>(args: SelectSubset<T, BenutzerRolleCreateArgs<ExtArgs>>): Prisma__BenutzerRolleClient<$Result.GetResult<Prisma.$BenutzerRollePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BenutzerRolles.
     * @param {BenutzerRolleCreateManyArgs} args - Arguments to create many BenutzerRolles.
     * @example
     * // Create many BenutzerRolles
     * const benutzerRolle = await prisma.benutzerRolle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BenutzerRolleCreateManyArgs>(args?: SelectSubset<T, BenutzerRolleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BenutzerRolle.
     * @param {BenutzerRolleDeleteArgs} args - Arguments to delete one BenutzerRolle.
     * @example
     * // Delete one BenutzerRolle
     * const BenutzerRolle = await prisma.benutzerRolle.delete({
     *   where: {
     *     // ... filter to delete one BenutzerRolle
     *   }
     * })
     * 
     */
    delete<T extends BenutzerRolleDeleteArgs>(args: SelectSubset<T, BenutzerRolleDeleteArgs<ExtArgs>>): Prisma__BenutzerRolleClient<$Result.GetResult<Prisma.$BenutzerRollePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BenutzerRolle.
     * @param {BenutzerRolleUpdateArgs} args - Arguments to update one BenutzerRolle.
     * @example
     * // Update one BenutzerRolle
     * const benutzerRolle = await prisma.benutzerRolle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BenutzerRolleUpdateArgs>(args: SelectSubset<T, BenutzerRolleUpdateArgs<ExtArgs>>): Prisma__BenutzerRolleClient<$Result.GetResult<Prisma.$BenutzerRollePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BenutzerRolles.
     * @param {BenutzerRolleDeleteManyArgs} args - Arguments to filter BenutzerRolles to delete.
     * @example
     * // Delete a few BenutzerRolles
     * const { count } = await prisma.benutzerRolle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BenutzerRolleDeleteManyArgs>(args?: SelectSubset<T, BenutzerRolleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BenutzerRolles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerRolleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BenutzerRolles
     * const benutzerRolle = await prisma.benutzerRolle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BenutzerRolleUpdateManyArgs>(args: SelectSubset<T, BenutzerRolleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BenutzerRolle.
     * @param {BenutzerRolleUpsertArgs} args - Arguments to update or create a BenutzerRolle.
     * @example
     * // Update or create a BenutzerRolle
     * const benutzerRolle = await prisma.benutzerRolle.upsert({
     *   create: {
     *     // ... data to create a BenutzerRolle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BenutzerRolle we want to update
     *   }
     * })
     */
    upsert<T extends BenutzerRolleUpsertArgs>(args: SelectSubset<T, BenutzerRolleUpsertArgs<ExtArgs>>): Prisma__BenutzerRolleClient<$Result.GetResult<Prisma.$BenutzerRollePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BenutzerRolles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerRolleCountArgs} args - Arguments to filter BenutzerRolles to count.
     * @example
     * // Count the number of BenutzerRolles
     * const count = await prisma.benutzerRolle.count({
     *   where: {
     *     // ... the filter for the BenutzerRolles we want to count
     *   }
     * })
    **/
    count<T extends BenutzerRolleCountArgs>(
      args?: Subset<T, BenutzerRolleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BenutzerRolleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BenutzerRolle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerRolleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BenutzerRolleAggregateArgs>(args: Subset<T, BenutzerRolleAggregateArgs>): Prisma.PrismaPromise<GetBenutzerRolleAggregateType<T>>

    /**
     * Group by BenutzerRolle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerRolleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BenutzerRolleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BenutzerRolleGroupByArgs['orderBy'] }
        : { orderBy?: BenutzerRolleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BenutzerRolleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBenutzerRolleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BenutzerRolle model
   */
  readonly fields: BenutzerRolleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BenutzerRolle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BenutzerRolleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    benutzer<T extends BenutzerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BenutzerDefaultArgs<ExtArgs>>): Prisma__BenutzerClient<$Result.GetResult<Prisma.$BenutzerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rolle<T extends RolleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolleDefaultArgs<ExtArgs>>): Prisma__RolleClient<$Result.GetResult<Prisma.$RollePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BenutzerRolle model
   */
  interface BenutzerRolleFieldRefs {
    readonly id: FieldRef<"BenutzerRolle", 'Int'>
    readonly benutzer_id: FieldRef<"BenutzerRolle", 'Int'>
    readonly rolle_id: FieldRef<"BenutzerRolle", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BenutzerRolle findUnique
   */
  export type BenutzerRolleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerRolle
     */
    select?: BenutzerRolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerRolle
     */
    omit?: BenutzerRolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerRolleInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerRolle to fetch.
     */
    where: BenutzerRolleWhereUniqueInput
  }

  /**
   * BenutzerRolle findUniqueOrThrow
   */
  export type BenutzerRolleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerRolle
     */
    select?: BenutzerRolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerRolle
     */
    omit?: BenutzerRolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerRolleInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerRolle to fetch.
     */
    where: BenutzerRolleWhereUniqueInput
  }

  /**
   * BenutzerRolle findFirst
   */
  export type BenutzerRolleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerRolle
     */
    select?: BenutzerRolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerRolle
     */
    omit?: BenutzerRolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerRolleInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerRolle to fetch.
     */
    where?: BenutzerRolleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenutzerRolles to fetch.
     */
    orderBy?: BenutzerRolleOrderByWithRelationInput | BenutzerRolleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BenutzerRolles.
     */
    cursor?: BenutzerRolleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenutzerRolles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenutzerRolles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BenutzerRolles.
     */
    distinct?: BenutzerRolleScalarFieldEnum | BenutzerRolleScalarFieldEnum[]
  }

  /**
   * BenutzerRolle findFirstOrThrow
   */
  export type BenutzerRolleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerRolle
     */
    select?: BenutzerRolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerRolle
     */
    omit?: BenutzerRolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerRolleInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerRolle to fetch.
     */
    where?: BenutzerRolleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenutzerRolles to fetch.
     */
    orderBy?: BenutzerRolleOrderByWithRelationInput | BenutzerRolleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BenutzerRolles.
     */
    cursor?: BenutzerRolleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenutzerRolles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenutzerRolles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BenutzerRolles.
     */
    distinct?: BenutzerRolleScalarFieldEnum | BenutzerRolleScalarFieldEnum[]
  }

  /**
   * BenutzerRolle findMany
   */
  export type BenutzerRolleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerRolle
     */
    select?: BenutzerRolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerRolle
     */
    omit?: BenutzerRolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerRolleInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerRolles to fetch.
     */
    where?: BenutzerRolleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenutzerRolles to fetch.
     */
    orderBy?: BenutzerRolleOrderByWithRelationInput | BenutzerRolleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BenutzerRolles.
     */
    cursor?: BenutzerRolleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenutzerRolles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenutzerRolles.
     */
    skip?: number
    distinct?: BenutzerRolleScalarFieldEnum | BenutzerRolleScalarFieldEnum[]
  }

  /**
   * BenutzerRolle create
   */
  export type BenutzerRolleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerRolle
     */
    select?: BenutzerRolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerRolle
     */
    omit?: BenutzerRolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerRolleInclude<ExtArgs> | null
    /**
     * The data needed to create a BenutzerRolle.
     */
    data: XOR<BenutzerRolleCreateInput, BenutzerRolleUncheckedCreateInput>
  }

  /**
   * BenutzerRolle createMany
   */
  export type BenutzerRolleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BenutzerRolles.
     */
    data: BenutzerRolleCreateManyInput | BenutzerRolleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BenutzerRolle update
   */
  export type BenutzerRolleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerRolle
     */
    select?: BenutzerRolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerRolle
     */
    omit?: BenutzerRolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerRolleInclude<ExtArgs> | null
    /**
     * The data needed to update a BenutzerRolle.
     */
    data: XOR<BenutzerRolleUpdateInput, BenutzerRolleUncheckedUpdateInput>
    /**
     * Choose, which BenutzerRolle to update.
     */
    where: BenutzerRolleWhereUniqueInput
  }

  /**
   * BenutzerRolle updateMany
   */
  export type BenutzerRolleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BenutzerRolles.
     */
    data: XOR<BenutzerRolleUpdateManyMutationInput, BenutzerRolleUncheckedUpdateManyInput>
    /**
     * Filter which BenutzerRolles to update
     */
    where?: BenutzerRolleWhereInput
    /**
     * Limit how many BenutzerRolles to update.
     */
    limit?: number
  }

  /**
   * BenutzerRolle upsert
   */
  export type BenutzerRolleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerRolle
     */
    select?: BenutzerRolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerRolle
     */
    omit?: BenutzerRolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerRolleInclude<ExtArgs> | null
    /**
     * The filter to search for the BenutzerRolle to update in case it exists.
     */
    where: BenutzerRolleWhereUniqueInput
    /**
     * In case the BenutzerRolle found by the `where` argument doesn't exist, create a new BenutzerRolle with this data.
     */
    create: XOR<BenutzerRolleCreateInput, BenutzerRolleUncheckedCreateInput>
    /**
     * In case the BenutzerRolle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BenutzerRolleUpdateInput, BenutzerRolleUncheckedUpdateInput>
  }

  /**
   * BenutzerRolle delete
   */
  export type BenutzerRolleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerRolle
     */
    select?: BenutzerRolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerRolle
     */
    omit?: BenutzerRolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerRolleInclude<ExtArgs> | null
    /**
     * Filter which BenutzerRolle to delete.
     */
    where: BenutzerRolleWhereUniqueInput
  }

  /**
   * BenutzerRolle deleteMany
   */
  export type BenutzerRolleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BenutzerRolles to delete
     */
    where?: BenutzerRolleWhereInput
    /**
     * Limit how many BenutzerRolles to delete.
     */
    limit?: number
  }

  /**
   * BenutzerRolle without action
   */
  export type BenutzerRolleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerRolle
     */
    select?: BenutzerRolleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerRolle
     */
    omit?: BenutzerRolleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerRolleInclude<ExtArgs> | null
  }


  /**
   * Model Klasse
   */

  export type AggregateKlasse = {
    _count: KlasseCountAggregateOutputType | null
    _avg: KlasseAvgAggregateOutputType | null
    _sum: KlasseSumAggregateOutputType | null
    _min: KlasseMinAggregateOutputType | null
    _max: KlasseMaxAggregateOutputType | null
  }

  export type KlasseAvgAggregateOutputType = {
    id: number | null
    jahrgang: number | null
  }

  export type KlasseSumAggregateOutputType = {
    id: number | null
    jahrgang: number | null
  }

  export type KlasseMinAggregateOutputType = {
    id: number | null
    name: string | null
    jahrgang: number | null
  }

  export type KlasseMaxAggregateOutputType = {
    id: number | null
    name: string | null
    jahrgang: number | null
  }

  export type KlasseCountAggregateOutputType = {
    id: number
    name: number
    jahrgang: number
    _all: number
  }


  export type KlasseAvgAggregateInputType = {
    id?: true
    jahrgang?: true
  }

  export type KlasseSumAggregateInputType = {
    id?: true
    jahrgang?: true
  }

  export type KlasseMinAggregateInputType = {
    id?: true
    name?: true
    jahrgang?: true
  }

  export type KlasseMaxAggregateInputType = {
    id?: true
    name?: true
    jahrgang?: true
  }

  export type KlasseCountAggregateInputType = {
    id?: true
    name?: true
    jahrgang?: true
    _all?: true
  }

  export type KlasseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Klasse to aggregate.
     */
    where?: KlasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Klasses to fetch.
     */
    orderBy?: KlasseOrderByWithRelationInput | KlasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KlasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Klasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Klasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Klasses
    **/
    _count?: true | KlasseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KlasseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KlasseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KlasseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KlasseMaxAggregateInputType
  }

  export type GetKlasseAggregateType<T extends KlasseAggregateArgs> = {
        [P in keyof T & keyof AggregateKlasse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKlasse[P]>
      : GetScalarType<T[P], AggregateKlasse[P]>
  }




  export type KlasseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KlasseWhereInput
    orderBy?: KlasseOrderByWithAggregationInput | KlasseOrderByWithAggregationInput[]
    by: KlasseScalarFieldEnum[] | KlasseScalarFieldEnum
    having?: KlasseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KlasseCountAggregateInputType | true
    _avg?: KlasseAvgAggregateInputType
    _sum?: KlasseSumAggregateInputType
    _min?: KlasseMinAggregateInputType
    _max?: KlasseMaxAggregateInputType
  }

  export type KlasseGroupByOutputType = {
    id: number
    name: string
    jahrgang: number
    _count: KlasseCountAggregateOutputType | null
    _avg: KlasseAvgAggregateOutputType | null
    _sum: KlasseSumAggregateOutputType | null
    _min: KlasseMinAggregateOutputType | null
    _max: KlasseMaxAggregateOutputType | null
  }

  type GetKlasseGroupByPayload<T extends KlasseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KlasseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KlasseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KlasseGroupByOutputType[P]>
            : GetScalarType<T[P], KlasseGroupByOutputType[P]>
        }
      >
    >


  export type KlasseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    jahrgang?: boolean
    benutzer_klassen?: boolean | Klasse$benutzer_klassenArgs<ExtArgs>
    _count?: boolean | KlasseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["klasse"]>



  export type KlasseSelectScalar = {
    id?: boolean
    name?: boolean
    jahrgang?: boolean
  }

  export type KlasseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "jahrgang", ExtArgs["result"]["klasse"]>
  export type KlasseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benutzer_klassen?: boolean | Klasse$benutzer_klassenArgs<ExtArgs>
    _count?: boolean | KlasseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $KlassePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Klasse"
    objects: {
      benutzer_klassen: Prisma.$BenutzerKlassePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      jahrgang: number
    }, ExtArgs["result"]["klasse"]>
    composites: {}
  }

  type KlasseGetPayload<S extends boolean | null | undefined | KlasseDefaultArgs> = $Result.GetResult<Prisma.$KlassePayload, S>

  type KlasseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KlasseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KlasseCountAggregateInputType | true
    }

  export interface KlasseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Klasse'], meta: { name: 'Klasse' } }
    /**
     * Find zero or one Klasse that matches the filter.
     * @param {KlasseFindUniqueArgs} args - Arguments to find a Klasse
     * @example
     * // Get one Klasse
     * const klasse = await prisma.klasse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KlasseFindUniqueArgs>(args: SelectSubset<T, KlasseFindUniqueArgs<ExtArgs>>): Prisma__KlasseClient<$Result.GetResult<Prisma.$KlassePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Klasse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KlasseFindUniqueOrThrowArgs} args - Arguments to find a Klasse
     * @example
     * // Get one Klasse
     * const klasse = await prisma.klasse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KlasseFindUniqueOrThrowArgs>(args: SelectSubset<T, KlasseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KlasseClient<$Result.GetResult<Prisma.$KlassePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Klasse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlasseFindFirstArgs} args - Arguments to find a Klasse
     * @example
     * // Get one Klasse
     * const klasse = await prisma.klasse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KlasseFindFirstArgs>(args?: SelectSubset<T, KlasseFindFirstArgs<ExtArgs>>): Prisma__KlasseClient<$Result.GetResult<Prisma.$KlassePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Klasse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlasseFindFirstOrThrowArgs} args - Arguments to find a Klasse
     * @example
     * // Get one Klasse
     * const klasse = await prisma.klasse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KlasseFindFirstOrThrowArgs>(args?: SelectSubset<T, KlasseFindFirstOrThrowArgs<ExtArgs>>): Prisma__KlasseClient<$Result.GetResult<Prisma.$KlassePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Klasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlasseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Klasses
     * const klasses = await prisma.klasse.findMany()
     * 
     * // Get first 10 Klasses
     * const klasses = await prisma.klasse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const klasseWithIdOnly = await prisma.klasse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KlasseFindManyArgs>(args?: SelectSubset<T, KlasseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KlassePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Klasse.
     * @param {KlasseCreateArgs} args - Arguments to create a Klasse.
     * @example
     * // Create one Klasse
     * const Klasse = await prisma.klasse.create({
     *   data: {
     *     // ... data to create a Klasse
     *   }
     * })
     * 
     */
    create<T extends KlasseCreateArgs>(args: SelectSubset<T, KlasseCreateArgs<ExtArgs>>): Prisma__KlasseClient<$Result.GetResult<Prisma.$KlassePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Klasses.
     * @param {KlasseCreateManyArgs} args - Arguments to create many Klasses.
     * @example
     * // Create many Klasses
     * const klasse = await prisma.klasse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KlasseCreateManyArgs>(args?: SelectSubset<T, KlasseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Klasse.
     * @param {KlasseDeleteArgs} args - Arguments to delete one Klasse.
     * @example
     * // Delete one Klasse
     * const Klasse = await prisma.klasse.delete({
     *   where: {
     *     // ... filter to delete one Klasse
     *   }
     * })
     * 
     */
    delete<T extends KlasseDeleteArgs>(args: SelectSubset<T, KlasseDeleteArgs<ExtArgs>>): Prisma__KlasseClient<$Result.GetResult<Prisma.$KlassePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Klasse.
     * @param {KlasseUpdateArgs} args - Arguments to update one Klasse.
     * @example
     * // Update one Klasse
     * const klasse = await prisma.klasse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KlasseUpdateArgs>(args: SelectSubset<T, KlasseUpdateArgs<ExtArgs>>): Prisma__KlasseClient<$Result.GetResult<Prisma.$KlassePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Klasses.
     * @param {KlasseDeleteManyArgs} args - Arguments to filter Klasses to delete.
     * @example
     * // Delete a few Klasses
     * const { count } = await prisma.klasse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KlasseDeleteManyArgs>(args?: SelectSubset<T, KlasseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Klasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlasseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Klasses
     * const klasse = await prisma.klasse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KlasseUpdateManyArgs>(args: SelectSubset<T, KlasseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Klasse.
     * @param {KlasseUpsertArgs} args - Arguments to update or create a Klasse.
     * @example
     * // Update or create a Klasse
     * const klasse = await prisma.klasse.upsert({
     *   create: {
     *     // ... data to create a Klasse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Klasse we want to update
     *   }
     * })
     */
    upsert<T extends KlasseUpsertArgs>(args: SelectSubset<T, KlasseUpsertArgs<ExtArgs>>): Prisma__KlasseClient<$Result.GetResult<Prisma.$KlassePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Klasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlasseCountArgs} args - Arguments to filter Klasses to count.
     * @example
     * // Count the number of Klasses
     * const count = await prisma.klasse.count({
     *   where: {
     *     // ... the filter for the Klasses we want to count
     *   }
     * })
    **/
    count<T extends KlasseCountArgs>(
      args?: Subset<T, KlasseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KlasseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Klasse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlasseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KlasseAggregateArgs>(args: Subset<T, KlasseAggregateArgs>): Prisma.PrismaPromise<GetKlasseAggregateType<T>>

    /**
     * Group by Klasse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KlasseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KlasseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KlasseGroupByArgs['orderBy'] }
        : { orderBy?: KlasseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KlasseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKlasseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Klasse model
   */
  readonly fields: KlasseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Klasse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KlasseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    benutzer_klassen<T extends Klasse$benutzer_klassenArgs<ExtArgs> = {}>(args?: Subset<T, Klasse$benutzer_klassenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenutzerKlassePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Klasse model
   */
  interface KlasseFieldRefs {
    readonly id: FieldRef<"Klasse", 'Int'>
    readonly name: FieldRef<"Klasse", 'String'>
    readonly jahrgang: FieldRef<"Klasse", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Klasse findUnique
   */
  export type KlasseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Klasse
     */
    select?: KlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Klasse
     */
    omit?: KlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KlasseInclude<ExtArgs> | null
    /**
     * Filter, which Klasse to fetch.
     */
    where: KlasseWhereUniqueInput
  }

  /**
   * Klasse findUniqueOrThrow
   */
  export type KlasseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Klasse
     */
    select?: KlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Klasse
     */
    omit?: KlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KlasseInclude<ExtArgs> | null
    /**
     * Filter, which Klasse to fetch.
     */
    where: KlasseWhereUniqueInput
  }

  /**
   * Klasse findFirst
   */
  export type KlasseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Klasse
     */
    select?: KlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Klasse
     */
    omit?: KlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KlasseInclude<ExtArgs> | null
    /**
     * Filter, which Klasse to fetch.
     */
    where?: KlasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Klasses to fetch.
     */
    orderBy?: KlasseOrderByWithRelationInput | KlasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Klasses.
     */
    cursor?: KlasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Klasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Klasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Klasses.
     */
    distinct?: KlasseScalarFieldEnum | KlasseScalarFieldEnum[]
  }

  /**
   * Klasse findFirstOrThrow
   */
  export type KlasseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Klasse
     */
    select?: KlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Klasse
     */
    omit?: KlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KlasseInclude<ExtArgs> | null
    /**
     * Filter, which Klasse to fetch.
     */
    where?: KlasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Klasses to fetch.
     */
    orderBy?: KlasseOrderByWithRelationInput | KlasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Klasses.
     */
    cursor?: KlasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Klasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Klasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Klasses.
     */
    distinct?: KlasseScalarFieldEnum | KlasseScalarFieldEnum[]
  }

  /**
   * Klasse findMany
   */
  export type KlasseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Klasse
     */
    select?: KlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Klasse
     */
    omit?: KlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KlasseInclude<ExtArgs> | null
    /**
     * Filter, which Klasses to fetch.
     */
    where?: KlasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Klasses to fetch.
     */
    orderBy?: KlasseOrderByWithRelationInput | KlasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Klasses.
     */
    cursor?: KlasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Klasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Klasses.
     */
    skip?: number
    distinct?: KlasseScalarFieldEnum | KlasseScalarFieldEnum[]
  }

  /**
   * Klasse create
   */
  export type KlasseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Klasse
     */
    select?: KlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Klasse
     */
    omit?: KlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KlasseInclude<ExtArgs> | null
    /**
     * The data needed to create a Klasse.
     */
    data: XOR<KlasseCreateInput, KlasseUncheckedCreateInput>
  }

  /**
   * Klasse createMany
   */
  export type KlasseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Klasses.
     */
    data: KlasseCreateManyInput | KlasseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Klasse update
   */
  export type KlasseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Klasse
     */
    select?: KlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Klasse
     */
    omit?: KlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KlasseInclude<ExtArgs> | null
    /**
     * The data needed to update a Klasse.
     */
    data: XOR<KlasseUpdateInput, KlasseUncheckedUpdateInput>
    /**
     * Choose, which Klasse to update.
     */
    where: KlasseWhereUniqueInput
  }

  /**
   * Klasse updateMany
   */
  export type KlasseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Klasses.
     */
    data: XOR<KlasseUpdateManyMutationInput, KlasseUncheckedUpdateManyInput>
    /**
     * Filter which Klasses to update
     */
    where?: KlasseWhereInput
    /**
     * Limit how many Klasses to update.
     */
    limit?: number
  }

  /**
   * Klasse upsert
   */
  export type KlasseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Klasse
     */
    select?: KlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Klasse
     */
    omit?: KlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KlasseInclude<ExtArgs> | null
    /**
     * The filter to search for the Klasse to update in case it exists.
     */
    where: KlasseWhereUniqueInput
    /**
     * In case the Klasse found by the `where` argument doesn't exist, create a new Klasse with this data.
     */
    create: XOR<KlasseCreateInput, KlasseUncheckedCreateInput>
    /**
     * In case the Klasse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KlasseUpdateInput, KlasseUncheckedUpdateInput>
  }

  /**
   * Klasse delete
   */
  export type KlasseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Klasse
     */
    select?: KlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Klasse
     */
    omit?: KlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KlasseInclude<ExtArgs> | null
    /**
     * Filter which Klasse to delete.
     */
    where: KlasseWhereUniqueInput
  }

  /**
   * Klasse deleteMany
   */
  export type KlasseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Klasses to delete
     */
    where?: KlasseWhereInput
    /**
     * Limit how many Klasses to delete.
     */
    limit?: number
  }

  /**
   * Klasse.benutzer_klassen
   */
  export type Klasse$benutzer_klassenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerKlasse
     */
    select?: BenutzerKlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerKlasse
     */
    omit?: BenutzerKlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerKlasseInclude<ExtArgs> | null
    where?: BenutzerKlasseWhereInput
    orderBy?: BenutzerKlasseOrderByWithRelationInput | BenutzerKlasseOrderByWithRelationInput[]
    cursor?: BenutzerKlasseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BenutzerKlasseScalarFieldEnum | BenutzerKlasseScalarFieldEnum[]
  }

  /**
   * Klasse without action
   */
  export type KlasseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Klasse
     */
    select?: KlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Klasse
     */
    omit?: KlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KlasseInclude<ExtArgs> | null
  }


  /**
   * Model BenutzerKlasse
   */

  export type AggregateBenutzerKlasse = {
    _count: BenutzerKlasseCountAggregateOutputType | null
    _avg: BenutzerKlasseAvgAggregateOutputType | null
    _sum: BenutzerKlasseSumAggregateOutputType | null
    _min: BenutzerKlasseMinAggregateOutputType | null
    _max: BenutzerKlasseMaxAggregateOutputType | null
  }

  export type BenutzerKlasseAvgAggregateOutputType = {
    id: number | null
    benutzer_id: number | null
    klasse_id: number | null
  }

  export type BenutzerKlasseSumAggregateOutputType = {
    id: number | null
    benutzer_id: number | null
    klasse_id: number | null
  }

  export type BenutzerKlasseMinAggregateOutputType = {
    id: number | null
    benutzer_id: number | null
    klasse_id: number | null
  }

  export type BenutzerKlasseMaxAggregateOutputType = {
    id: number | null
    benutzer_id: number | null
    klasse_id: number | null
  }

  export type BenutzerKlasseCountAggregateOutputType = {
    id: number
    benutzer_id: number
    klasse_id: number
    _all: number
  }


  export type BenutzerKlasseAvgAggregateInputType = {
    id?: true
    benutzer_id?: true
    klasse_id?: true
  }

  export type BenutzerKlasseSumAggregateInputType = {
    id?: true
    benutzer_id?: true
    klasse_id?: true
  }

  export type BenutzerKlasseMinAggregateInputType = {
    id?: true
    benutzer_id?: true
    klasse_id?: true
  }

  export type BenutzerKlasseMaxAggregateInputType = {
    id?: true
    benutzer_id?: true
    klasse_id?: true
  }

  export type BenutzerKlasseCountAggregateInputType = {
    id?: true
    benutzer_id?: true
    klasse_id?: true
    _all?: true
  }

  export type BenutzerKlasseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BenutzerKlasse to aggregate.
     */
    where?: BenutzerKlasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenutzerKlasses to fetch.
     */
    orderBy?: BenutzerKlasseOrderByWithRelationInput | BenutzerKlasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BenutzerKlasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenutzerKlasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenutzerKlasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BenutzerKlasses
    **/
    _count?: true | BenutzerKlasseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BenutzerKlasseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BenutzerKlasseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BenutzerKlasseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BenutzerKlasseMaxAggregateInputType
  }

  export type GetBenutzerKlasseAggregateType<T extends BenutzerKlasseAggregateArgs> = {
        [P in keyof T & keyof AggregateBenutzerKlasse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBenutzerKlasse[P]>
      : GetScalarType<T[P], AggregateBenutzerKlasse[P]>
  }




  export type BenutzerKlasseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BenutzerKlasseWhereInput
    orderBy?: BenutzerKlasseOrderByWithAggregationInput | BenutzerKlasseOrderByWithAggregationInput[]
    by: BenutzerKlasseScalarFieldEnum[] | BenutzerKlasseScalarFieldEnum
    having?: BenutzerKlasseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BenutzerKlasseCountAggregateInputType | true
    _avg?: BenutzerKlasseAvgAggregateInputType
    _sum?: BenutzerKlasseSumAggregateInputType
    _min?: BenutzerKlasseMinAggregateInputType
    _max?: BenutzerKlasseMaxAggregateInputType
  }

  export type BenutzerKlasseGroupByOutputType = {
    id: number
    benutzer_id: number
    klasse_id: number
    _count: BenutzerKlasseCountAggregateOutputType | null
    _avg: BenutzerKlasseAvgAggregateOutputType | null
    _sum: BenutzerKlasseSumAggregateOutputType | null
    _min: BenutzerKlasseMinAggregateOutputType | null
    _max: BenutzerKlasseMaxAggregateOutputType | null
  }

  type GetBenutzerKlasseGroupByPayload<T extends BenutzerKlasseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BenutzerKlasseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BenutzerKlasseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BenutzerKlasseGroupByOutputType[P]>
            : GetScalarType<T[P], BenutzerKlasseGroupByOutputType[P]>
        }
      >
    >


  export type BenutzerKlasseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    benutzer_id?: boolean
    klasse_id?: boolean
    klasse?: boolean | KlasseDefaultArgs<ExtArgs>
    benutzer?: boolean | BenutzerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["benutzerKlasse"]>



  export type BenutzerKlasseSelectScalar = {
    id?: boolean
    benutzer_id?: boolean
    klasse_id?: boolean
  }

  export type BenutzerKlasseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "benutzer_id" | "klasse_id", ExtArgs["result"]["benutzerKlasse"]>
  export type BenutzerKlasseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    klasse?: boolean | KlasseDefaultArgs<ExtArgs>
    benutzer?: boolean | BenutzerDefaultArgs<ExtArgs>
  }

  export type $BenutzerKlassePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BenutzerKlasse"
    objects: {
      klasse: Prisma.$KlassePayload<ExtArgs>
      benutzer: Prisma.$BenutzerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      benutzer_id: number
      klasse_id: number
    }, ExtArgs["result"]["benutzerKlasse"]>
    composites: {}
  }

  type BenutzerKlasseGetPayload<S extends boolean | null | undefined | BenutzerKlasseDefaultArgs> = $Result.GetResult<Prisma.$BenutzerKlassePayload, S>

  type BenutzerKlasseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BenutzerKlasseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BenutzerKlasseCountAggregateInputType | true
    }

  export interface BenutzerKlasseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BenutzerKlasse'], meta: { name: 'BenutzerKlasse' } }
    /**
     * Find zero or one BenutzerKlasse that matches the filter.
     * @param {BenutzerKlasseFindUniqueArgs} args - Arguments to find a BenutzerKlasse
     * @example
     * // Get one BenutzerKlasse
     * const benutzerKlasse = await prisma.benutzerKlasse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BenutzerKlasseFindUniqueArgs>(args: SelectSubset<T, BenutzerKlasseFindUniqueArgs<ExtArgs>>): Prisma__BenutzerKlasseClient<$Result.GetResult<Prisma.$BenutzerKlassePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BenutzerKlasse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BenutzerKlasseFindUniqueOrThrowArgs} args - Arguments to find a BenutzerKlasse
     * @example
     * // Get one BenutzerKlasse
     * const benutzerKlasse = await prisma.benutzerKlasse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BenutzerKlasseFindUniqueOrThrowArgs>(args: SelectSubset<T, BenutzerKlasseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BenutzerKlasseClient<$Result.GetResult<Prisma.$BenutzerKlassePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BenutzerKlasse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerKlasseFindFirstArgs} args - Arguments to find a BenutzerKlasse
     * @example
     * // Get one BenutzerKlasse
     * const benutzerKlasse = await prisma.benutzerKlasse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BenutzerKlasseFindFirstArgs>(args?: SelectSubset<T, BenutzerKlasseFindFirstArgs<ExtArgs>>): Prisma__BenutzerKlasseClient<$Result.GetResult<Prisma.$BenutzerKlassePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BenutzerKlasse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerKlasseFindFirstOrThrowArgs} args - Arguments to find a BenutzerKlasse
     * @example
     * // Get one BenutzerKlasse
     * const benutzerKlasse = await prisma.benutzerKlasse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BenutzerKlasseFindFirstOrThrowArgs>(args?: SelectSubset<T, BenutzerKlasseFindFirstOrThrowArgs<ExtArgs>>): Prisma__BenutzerKlasseClient<$Result.GetResult<Prisma.$BenutzerKlassePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BenutzerKlasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerKlasseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BenutzerKlasses
     * const benutzerKlasses = await prisma.benutzerKlasse.findMany()
     * 
     * // Get first 10 BenutzerKlasses
     * const benutzerKlasses = await prisma.benutzerKlasse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const benutzerKlasseWithIdOnly = await prisma.benutzerKlasse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BenutzerKlasseFindManyArgs>(args?: SelectSubset<T, BenutzerKlasseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenutzerKlassePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BenutzerKlasse.
     * @param {BenutzerKlasseCreateArgs} args - Arguments to create a BenutzerKlasse.
     * @example
     * // Create one BenutzerKlasse
     * const BenutzerKlasse = await prisma.benutzerKlasse.create({
     *   data: {
     *     // ... data to create a BenutzerKlasse
     *   }
     * })
     * 
     */
    create<T extends BenutzerKlasseCreateArgs>(args: SelectSubset<T, BenutzerKlasseCreateArgs<ExtArgs>>): Prisma__BenutzerKlasseClient<$Result.GetResult<Prisma.$BenutzerKlassePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BenutzerKlasses.
     * @param {BenutzerKlasseCreateManyArgs} args - Arguments to create many BenutzerKlasses.
     * @example
     * // Create many BenutzerKlasses
     * const benutzerKlasse = await prisma.benutzerKlasse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BenutzerKlasseCreateManyArgs>(args?: SelectSubset<T, BenutzerKlasseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BenutzerKlasse.
     * @param {BenutzerKlasseDeleteArgs} args - Arguments to delete one BenutzerKlasse.
     * @example
     * // Delete one BenutzerKlasse
     * const BenutzerKlasse = await prisma.benutzerKlasse.delete({
     *   where: {
     *     // ... filter to delete one BenutzerKlasse
     *   }
     * })
     * 
     */
    delete<T extends BenutzerKlasseDeleteArgs>(args: SelectSubset<T, BenutzerKlasseDeleteArgs<ExtArgs>>): Prisma__BenutzerKlasseClient<$Result.GetResult<Prisma.$BenutzerKlassePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BenutzerKlasse.
     * @param {BenutzerKlasseUpdateArgs} args - Arguments to update one BenutzerKlasse.
     * @example
     * // Update one BenutzerKlasse
     * const benutzerKlasse = await prisma.benutzerKlasse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BenutzerKlasseUpdateArgs>(args: SelectSubset<T, BenutzerKlasseUpdateArgs<ExtArgs>>): Prisma__BenutzerKlasseClient<$Result.GetResult<Prisma.$BenutzerKlassePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BenutzerKlasses.
     * @param {BenutzerKlasseDeleteManyArgs} args - Arguments to filter BenutzerKlasses to delete.
     * @example
     * // Delete a few BenutzerKlasses
     * const { count } = await prisma.benutzerKlasse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BenutzerKlasseDeleteManyArgs>(args?: SelectSubset<T, BenutzerKlasseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BenutzerKlasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerKlasseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BenutzerKlasses
     * const benutzerKlasse = await prisma.benutzerKlasse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BenutzerKlasseUpdateManyArgs>(args: SelectSubset<T, BenutzerKlasseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BenutzerKlasse.
     * @param {BenutzerKlasseUpsertArgs} args - Arguments to update or create a BenutzerKlasse.
     * @example
     * // Update or create a BenutzerKlasse
     * const benutzerKlasse = await prisma.benutzerKlasse.upsert({
     *   create: {
     *     // ... data to create a BenutzerKlasse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BenutzerKlasse we want to update
     *   }
     * })
     */
    upsert<T extends BenutzerKlasseUpsertArgs>(args: SelectSubset<T, BenutzerKlasseUpsertArgs<ExtArgs>>): Prisma__BenutzerKlasseClient<$Result.GetResult<Prisma.$BenutzerKlassePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BenutzerKlasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerKlasseCountArgs} args - Arguments to filter BenutzerKlasses to count.
     * @example
     * // Count the number of BenutzerKlasses
     * const count = await prisma.benutzerKlasse.count({
     *   where: {
     *     // ... the filter for the BenutzerKlasses we want to count
     *   }
     * })
    **/
    count<T extends BenutzerKlasseCountArgs>(
      args?: Subset<T, BenutzerKlasseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BenutzerKlasseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BenutzerKlasse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerKlasseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BenutzerKlasseAggregateArgs>(args: Subset<T, BenutzerKlasseAggregateArgs>): Prisma.PrismaPromise<GetBenutzerKlasseAggregateType<T>>

    /**
     * Group by BenutzerKlasse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerKlasseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BenutzerKlasseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BenutzerKlasseGroupByArgs['orderBy'] }
        : { orderBy?: BenutzerKlasseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BenutzerKlasseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBenutzerKlasseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BenutzerKlasse model
   */
  readonly fields: BenutzerKlasseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BenutzerKlasse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BenutzerKlasseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    klasse<T extends KlasseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KlasseDefaultArgs<ExtArgs>>): Prisma__KlasseClient<$Result.GetResult<Prisma.$KlassePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    benutzer<T extends BenutzerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BenutzerDefaultArgs<ExtArgs>>): Prisma__BenutzerClient<$Result.GetResult<Prisma.$BenutzerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BenutzerKlasse model
   */
  interface BenutzerKlasseFieldRefs {
    readonly id: FieldRef<"BenutzerKlasse", 'Int'>
    readonly benutzer_id: FieldRef<"BenutzerKlasse", 'Int'>
    readonly klasse_id: FieldRef<"BenutzerKlasse", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BenutzerKlasse findUnique
   */
  export type BenutzerKlasseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerKlasse
     */
    select?: BenutzerKlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerKlasse
     */
    omit?: BenutzerKlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerKlasseInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerKlasse to fetch.
     */
    where: BenutzerKlasseWhereUniqueInput
  }

  /**
   * BenutzerKlasse findUniqueOrThrow
   */
  export type BenutzerKlasseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerKlasse
     */
    select?: BenutzerKlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerKlasse
     */
    omit?: BenutzerKlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerKlasseInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerKlasse to fetch.
     */
    where: BenutzerKlasseWhereUniqueInput
  }

  /**
   * BenutzerKlasse findFirst
   */
  export type BenutzerKlasseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerKlasse
     */
    select?: BenutzerKlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerKlasse
     */
    omit?: BenutzerKlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerKlasseInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerKlasse to fetch.
     */
    where?: BenutzerKlasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenutzerKlasses to fetch.
     */
    orderBy?: BenutzerKlasseOrderByWithRelationInput | BenutzerKlasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BenutzerKlasses.
     */
    cursor?: BenutzerKlasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenutzerKlasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenutzerKlasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BenutzerKlasses.
     */
    distinct?: BenutzerKlasseScalarFieldEnum | BenutzerKlasseScalarFieldEnum[]
  }

  /**
   * BenutzerKlasse findFirstOrThrow
   */
  export type BenutzerKlasseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerKlasse
     */
    select?: BenutzerKlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerKlasse
     */
    omit?: BenutzerKlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerKlasseInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerKlasse to fetch.
     */
    where?: BenutzerKlasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenutzerKlasses to fetch.
     */
    orderBy?: BenutzerKlasseOrderByWithRelationInput | BenutzerKlasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BenutzerKlasses.
     */
    cursor?: BenutzerKlasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenutzerKlasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenutzerKlasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BenutzerKlasses.
     */
    distinct?: BenutzerKlasseScalarFieldEnum | BenutzerKlasseScalarFieldEnum[]
  }

  /**
   * BenutzerKlasse findMany
   */
  export type BenutzerKlasseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerKlasse
     */
    select?: BenutzerKlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerKlasse
     */
    omit?: BenutzerKlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerKlasseInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerKlasses to fetch.
     */
    where?: BenutzerKlasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenutzerKlasses to fetch.
     */
    orderBy?: BenutzerKlasseOrderByWithRelationInput | BenutzerKlasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BenutzerKlasses.
     */
    cursor?: BenutzerKlasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenutzerKlasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenutzerKlasses.
     */
    skip?: number
    distinct?: BenutzerKlasseScalarFieldEnum | BenutzerKlasseScalarFieldEnum[]
  }

  /**
   * BenutzerKlasse create
   */
  export type BenutzerKlasseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerKlasse
     */
    select?: BenutzerKlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerKlasse
     */
    omit?: BenutzerKlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerKlasseInclude<ExtArgs> | null
    /**
     * The data needed to create a BenutzerKlasse.
     */
    data: XOR<BenutzerKlasseCreateInput, BenutzerKlasseUncheckedCreateInput>
  }

  /**
   * BenutzerKlasse createMany
   */
  export type BenutzerKlasseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BenutzerKlasses.
     */
    data: BenutzerKlasseCreateManyInput | BenutzerKlasseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BenutzerKlasse update
   */
  export type BenutzerKlasseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerKlasse
     */
    select?: BenutzerKlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerKlasse
     */
    omit?: BenutzerKlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerKlasseInclude<ExtArgs> | null
    /**
     * The data needed to update a BenutzerKlasse.
     */
    data: XOR<BenutzerKlasseUpdateInput, BenutzerKlasseUncheckedUpdateInput>
    /**
     * Choose, which BenutzerKlasse to update.
     */
    where: BenutzerKlasseWhereUniqueInput
  }

  /**
   * BenutzerKlasse updateMany
   */
  export type BenutzerKlasseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BenutzerKlasses.
     */
    data: XOR<BenutzerKlasseUpdateManyMutationInput, BenutzerKlasseUncheckedUpdateManyInput>
    /**
     * Filter which BenutzerKlasses to update
     */
    where?: BenutzerKlasseWhereInput
    /**
     * Limit how many BenutzerKlasses to update.
     */
    limit?: number
  }

  /**
   * BenutzerKlasse upsert
   */
  export type BenutzerKlasseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerKlasse
     */
    select?: BenutzerKlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerKlasse
     */
    omit?: BenutzerKlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerKlasseInclude<ExtArgs> | null
    /**
     * The filter to search for the BenutzerKlasse to update in case it exists.
     */
    where: BenutzerKlasseWhereUniqueInput
    /**
     * In case the BenutzerKlasse found by the `where` argument doesn't exist, create a new BenutzerKlasse with this data.
     */
    create: XOR<BenutzerKlasseCreateInput, BenutzerKlasseUncheckedCreateInput>
    /**
     * In case the BenutzerKlasse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BenutzerKlasseUpdateInput, BenutzerKlasseUncheckedUpdateInput>
  }

  /**
   * BenutzerKlasse delete
   */
  export type BenutzerKlasseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerKlasse
     */
    select?: BenutzerKlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerKlasse
     */
    omit?: BenutzerKlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerKlasseInclude<ExtArgs> | null
    /**
     * Filter which BenutzerKlasse to delete.
     */
    where: BenutzerKlasseWhereUniqueInput
  }

  /**
   * BenutzerKlasse deleteMany
   */
  export type BenutzerKlasseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BenutzerKlasses to delete
     */
    where?: BenutzerKlasseWhereInput
    /**
     * Limit how many BenutzerKlasses to delete.
     */
    limit?: number
  }

  /**
   * BenutzerKlasse without action
   */
  export type BenutzerKlasseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerKlasse
     */
    select?: BenutzerKlasseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerKlasse
     */
    omit?: BenutzerKlasseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerKlasseInclude<ExtArgs> | null
  }


  /**
   * Model Fach
   */

  export type AggregateFach = {
    _count: FachCountAggregateOutputType | null
    _avg: FachAvgAggregateOutputType | null
    _sum: FachSumAggregateOutputType | null
    _min: FachMinAggregateOutputType | null
    _max: FachMaxAggregateOutputType | null
  }

  export type FachAvgAggregateOutputType = {
    id: number | null
  }

  export type FachSumAggregateOutputType = {
    id: number | null
  }

  export type FachMinAggregateOutputType = {
    id: number | null
    name: string | null
    kuerzel: string | null
  }

  export type FachMaxAggregateOutputType = {
    id: number | null
    name: string | null
    kuerzel: string | null
  }

  export type FachCountAggregateOutputType = {
    id: number
    name: number
    kuerzel: number
    _all: number
  }


  export type FachAvgAggregateInputType = {
    id?: true
  }

  export type FachSumAggregateInputType = {
    id?: true
  }

  export type FachMinAggregateInputType = {
    id?: true
    name?: true
    kuerzel?: true
  }

  export type FachMaxAggregateInputType = {
    id?: true
    name?: true
    kuerzel?: true
  }

  export type FachCountAggregateInputType = {
    id?: true
    name?: true
    kuerzel?: true
    _all?: true
  }

  export type FachAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fach to aggregate.
     */
    where?: FachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faches to fetch.
     */
    orderBy?: FachOrderByWithRelationInput | FachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faches
    **/
    _count?: true | FachCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FachAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FachSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FachMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FachMaxAggregateInputType
  }

  export type GetFachAggregateType<T extends FachAggregateArgs> = {
        [P in keyof T & keyof AggregateFach]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFach[P]>
      : GetScalarType<T[P], AggregateFach[P]>
  }




  export type FachGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FachWhereInput
    orderBy?: FachOrderByWithAggregationInput | FachOrderByWithAggregationInput[]
    by: FachScalarFieldEnum[] | FachScalarFieldEnum
    having?: FachScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FachCountAggregateInputType | true
    _avg?: FachAvgAggregateInputType
    _sum?: FachSumAggregateInputType
    _min?: FachMinAggregateInputType
    _max?: FachMaxAggregateInputType
  }

  export type FachGroupByOutputType = {
    id: number
    name: string
    kuerzel: string
    _count: FachCountAggregateOutputType | null
    _avg: FachAvgAggregateOutputType | null
    _sum: FachSumAggregateOutputType | null
    _min: FachMinAggregateOutputType | null
    _max: FachMaxAggregateOutputType | null
  }

  type GetFachGroupByPayload<T extends FachGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FachGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FachGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FachGroupByOutputType[P]>
            : GetScalarType<T[P], FachGroupByOutputType[P]>
        }
      >
    >


  export type FachSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    kuerzel?: boolean
    benutzer_faecher?: boolean | Fach$benutzer_faecherArgs<ExtArgs>
    _count?: boolean | FachCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fach"]>



  export type FachSelectScalar = {
    id?: boolean
    name?: boolean
    kuerzel?: boolean
  }

  export type FachOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "kuerzel", ExtArgs["result"]["fach"]>
  export type FachInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benutzer_faecher?: boolean | Fach$benutzer_faecherArgs<ExtArgs>
    _count?: boolean | FachCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FachPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fach"
    objects: {
      benutzer_faecher: Prisma.$BenutzerFachPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      kuerzel: string
    }, ExtArgs["result"]["fach"]>
    composites: {}
  }

  type FachGetPayload<S extends boolean | null | undefined | FachDefaultArgs> = $Result.GetResult<Prisma.$FachPayload, S>

  type FachCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FachFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FachCountAggregateInputType | true
    }

  export interface FachDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fach'], meta: { name: 'Fach' } }
    /**
     * Find zero or one Fach that matches the filter.
     * @param {FachFindUniqueArgs} args - Arguments to find a Fach
     * @example
     * // Get one Fach
     * const fach = await prisma.fach.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FachFindUniqueArgs>(args: SelectSubset<T, FachFindUniqueArgs<ExtArgs>>): Prisma__FachClient<$Result.GetResult<Prisma.$FachPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fach that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FachFindUniqueOrThrowArgs} args - Arguments to find a Fach
     * @example
     * // Get one Fach
     * const fach = await prisma.fach.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FachFindUniqueOrThrowArgs>(args: SelectSubset<T, FachFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FachClient<$Result.GetResult<Prisma.$FachPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fach that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FachFindFirstArgs} args - Arguments to find a Fach
     * @example
     * // Get one Fach
     * const fach = await prisma.fach.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FachFindFirstArgs>(args?: SelectSubset<T, FachFindFirstArgs<ExtArgs>>): Prisma__FachClient<$Result.GetResult<Prisma.$FachPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fach that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FachFindFirstOrThrowArgs} args - Arguments to find a Fach
     * @example
     * // Get one Fach
     * const fach = await prisma.fach.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FachFindFirstOrThrowArgs>(args?: SelectSubset<T, FachFindFirstOrThrowArgs<ExtArgs>>): Prisma__FachClient<$Result.GetResult<Prisma.$FachPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FachFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faches
     * const faches = await prisma.fach.findMany()
     * 
     * // Get first 10 Faches
     * const faches = await prisma.fach.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fachWithIdOnly = await prisma.fach.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FachFindManyArgs>(args?: SelectSubset<T, FachFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fach.
     * @param {FachCreateArgs} args - Arguments to create a Fach.
     * @example
     * // Create one Fach
     * const Fach = await prisma.fach.create({
     *   data: {
     *     // ... data to create a Fach
     *   }
     * })
     * 
     */
    create<T extends FachCreateArgs>(args: SelectSubset<T, FachCreateArgs<ExtArgs>>): Prisma__FachClient<$Result.GetResult<Prisma.$FachPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faches.
     * @param {FachCreateManyArgs} args - Arguments to create many Faches.
     * @example
     * // Create many Faches
     * const fach = await prisma.fach.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FachCreateManyArgs>(args?: SelectSubset<T, FachCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fach.
     * @param {FachDeleteArgs} args - Arguments to delete one Fach.
     * @example
     * // Delete one Fach
     * const Fach = await prisma.fach.delete({
     *   where: {
     *     // ... filter to delete one Fach
     *   }
     * })
     * 
     */
    delete<T extends FachDeleteArgs>(args: SelectSubset<T, FachDeleteArgs<ExtArgs>>): Prisma__FachClient<$Result.GetResult<Prisma.$FachPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fach.
     * @param {FachUpdateArgs} args - Arguments to update one Fach.
     * @example
     * // Update one Fach
     * const fach = await prisma.fach.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FachUpdateArgs>(args: SelectSubset<T, FachUpdateArgs<ExtArgs>>): Prisma__FachClient<$Result.GetResult<Prisma.$FachPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faches.
     * @param {FachDeleteManyArgs} args - Arguments to filter Faches to delete.
     * @example
     * // Delete a few Faches
     * const { count } = await prisma.fach.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FachDeleteManyArgs>(args?: SelectSubset<T, FachDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FachUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faches
     * const fach = await prisma.fach.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FachUpdateManyArgs>(args: SelectSubset<T, FachUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fach.
     * @param {FachUpsertArgs} args - Arguments to update or create a Fach.
     * @example
     * // Update or create a Fach
     * const fach = await prisma.fach.upsert({
     *   create: {
     *     // ... data to create a Fach
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fach we want to update
     *   }
     * })
     */
    upsert<T extends FachUpsertArgs>(args: SelectSubset<T, FachUpsertArgs<ExtArgs>>): Prisma__FachClient<$Result.GetResult<Prisma.$FachPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Faches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FachCountArgs} args - Arguments to filter Faches to count.
     * @example
     * // Count the number of Faches
     * const count = await prisma.fach.count({
     *   where: {
     *     // ... the filter for the Faches we want to count
     *   }
     * })
    **/
    count<T extends FachCountArgs>(
      args?: Subset<T, FachCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FachCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FachAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FachAggregateArgs>(args: Subset<T, FachAggregateArgs>): Prisma.PrismaPromise<GetFachAggregateType<T>>

    /**
     * Group by Fach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FachGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FachGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FachGroupByArgs['orderBy'] }
        : { orderBy?: FachGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FachGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFachGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fach model
   */
  readonly fields: FachFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fach.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FachClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    benutzer_faecher<T extends Fach$benutzer_faecherArgs<ExtArgs> = {}>(args?: Subset<T, Fach$benutzer_faecherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenutzerFachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fach model
   */
  interface FachFieldRefs {
    readonly id: FieldRef<"Fach", 'Int'>
    readonly name: FieldRef<"Fach", 'String'>
    readonly kuerzel: FieldRef<"Fach", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Fach findUnique
   */
  export type FachFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fach
     */
    select?: FachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fach
     */
    omit?: FachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FachInclude<ExtArgs> | null
    /**
     * Filter, which Fach to fetch.
     */
    where: FachWhereUniqueInput
  }

  /**
   * Fach findUniqueOrThrow
   */
  export type FachFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fach
     */
    select?: FachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fach
     */
    omit?: FachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FachInclude<ExtArgs> | null
    /**
     * Filter, which Fach to fetch.
     */
    where: FachWhereUniqueInput
  }

  /**
   * Fach findFirst
   */
  export type FachFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fach
     */
    select?: FachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fach
     */
    omit?: FachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FachInclude<ExtArgs> | null
    /**
     * Filter, which Fach to fetch.
     */
    where?: FachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faches to fetch.
     */
    orderBy?: FachOrderByWithRelationInput | FachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faches.
     */
    cursor?: FachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faches.
     */
    distinct?: FachScalarFieldEnum | FachScalarFieldEnum[]
  }

  /**
   * Fach findFirstOrThrow
   */
  export type FachFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fach
     */
    select?: FachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fach
     */
    omit?: FachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FachInclude<ExtArgs> | null
    /**
     * Filter, which Fach to fetch.
     */
    where?: FachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faches to fetch.
     */
    orderBy?: FachOrderByWithRelationInput | FachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faches.
     */
    cursor?: FachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faches.
     */
    distinct?: FachScalarFieldEnum | FachScalarFieldEnum[]
  }

  /**
   * Fach findMany
   */
  export type FachFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fach
     */
    select?: FachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fach
     */
    omit?: FachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FachInclude<ExtArgs> | null
    /**
     * Filter, which Faches to fetch.
     */
    where?: FachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faches to fetch.
     */
    orderBy?: FachOrderByWithRelationInput | FachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faches.
     */
    cursor?: FachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faches.
     */
    skip?: number
    distinct?: FachScalarFieldEnum | FachScalarFieldEnum[]
  }

  /**
   * Fach create
   */
  export type FachCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fach
     */
    select?: FachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fach
     */
    omit?: FachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FachInclude<ExtArgs> | null
    /**
     * The data needed to create a Fach.
     */
    data: XOR<FachCreateInput, FachUncheckedCreateInput>
  }

  /**
   * Fach createMany
   */
  export type FachCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Faches.
     */
    data: FachCreateManyInput | FachCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fach update
   */
  export type FachUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fach
     */
    select?: FachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fach
     */
    omit?: FachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FachInclude<ExtArgs> | null
    /**
     * The data needed to update a Fach.
     */
    data: XOR<FachUpdateInput, FachUncheckedUpdateInput>
    /**
     * Choose, which Fach to update.
     */
    where: FachWhereUniqueInput
  }

  /**
   * Fach updateMany
   */
  export type FachUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Faches.
     */
    data: XOR<FachUpdateManyMutationInput, FachUncheckedUpdateManyInput>
    /**
     * Filter which Faches to update
     */
    where?: FachWhereInput
    /**
     * Limit how many Faches to update.
     */
    limit?: number
  }

  /**
   * Fach upsert
   */
  export type FachUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fach
     */
    select?: FachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fach
     */
    omit?: FachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FachInclude<ExtArgs> | null
    /**
     * The filter to search for the Fach to update in case it exists.
     */
    where: FachWhereUniqueInput
    /**
     * In case the Fach found by the `where` argument doesn't exist, create a new Fach with this data.
     */
    create: XOR<FachCreateInput, FachUncheckedCreateInput>
    /**
     * In case the Fach was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FachUpdateInput, FachUncheckedUpdateInput>
  }

  /**
   * Fach delete
   */
  export type FachDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fach
     */
    select?: FachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fach
     */
    omit?: FachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FachInclude<ExtArgs> | null
    /**
     * Filter which Fach to delete.
     */
    where: FachWhereUniqueInput
  }

  /**
   * Fach deleteMany
   */
  export type FachDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faches to delete
     */
    where?: FachWhereInput
    /**
     * Limit how many Faches to delete.
     */
    limit?: number
  }

  /**
   * Fach.benutzer_faecher
   */
  export type Fach$benutzer_faecherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerFach
     */
    select?: BenutzerFachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerFach
     */
    omit?: BenutzerFachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerFachInclude<ExtArgs> | null
    where?: BenutzerFachWhereInput
    orderBy?: BenutzerFachOrderByWithRelationInput | BenutzerFachOrderByWithRelationInput[]
    cursor?: BenutzerFachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BenutzerFachScalarFieldEnum | BenutzerFachScalarFieldEnum[]
  }

  /**
   * Fach without action
   */
  export type FachDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fach
     */
    select?: FachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fach
     */
    omit?: FachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FachInclude<ExtArgs> | null
  }


  /**
   * Model BenutzerFach
   */

  export type AggregateBenutzerFach = {
    _count: BenutzerFachCountAggregateOutputType | null
    _avg: BenutzerFachAvgAggregateOutputType | null
    _sum: BenutzerFachSumAggregateOutputType | null
    _min: BenutzerFachMinAggregateOutputType | null
    _max: BenutzerFachMaxAggregateOutputType | null
  }

  export type BenutzerFachAvgAggregateOutputType = {
    id: number | null
    benutzer_id: number | null
    fach_id: number | null
  }

  export type BenutzerFachSumAggregateOutputType = {
    id: number | null
    benutzer_id: number | null
    fach_id: number | null
  }

  export type BenutzerFachMinAggregateOutputType = {
    id: number | null
    benutzer_id: number | null
    fach_id: number | null
  }

  export type BenutzerFachMaxAggregateOutputType = {
    id: number | null
    benutzer_id: number | null
    fach_id: number | null
  }

  export type BenutzerFachCountAggregateOutputType = {
    id: number
    benutzer_id: number
    fach_id: number
    _all: number
  }


  export type BenutzerFachAvgAggregateInputType = {
    id?: true
    benutzer_id?: true
    fach_id?: true
  }

  export type BenutzerFachSumAggregateInputType = {
    id?: true
    benutzer_id?: true
    fach_id?: true
  }

  export type BenutzerFachMinAggregateInputType = {
    id?: true
    benutzer_id?: true
    fach_id?: true
  }

  export type BenutzerFachMaxAggregateInputType = {
    id?: true
    benutzer_id?: true
    fach_id?: true
  }

  export type BenutzerFachCountAggregateInputType = {
    id?: true
    benutzer_id?: true
    fach_id?: true
    _all?: true
  }

  export type BenutzerFachAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BenutzerFach to aggregate.
     */
    where?: BenutzerFachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenutzerFaches to fetch.
     */
    orderBy?: BenutzerFachOrderByWithRelationInput | BenutzerFachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BenutzerFachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenutzerFaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenutzerFaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BenutzerFaches
    **/
    _count?: true | BenutzerFachCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BenutzerFachAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BenutzerFachSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BenutzerFachMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BenutzerFachMaxAggregateInputType
  }

  export type GetBenutzerFachAggregateType<T extends BenutzerFachAggregateArgs> = {
        [P in keyof T & keyof AggregateBenutzerFach]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBenutzerFach[P]>
      : GetScalarType<T[P], AggregateBenutzerFach[P]>
  }




  export type BenutzerFachGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BenutzerFachWhereInput
    orderBy?: BenutzerFachOrderByWithAggregationInput | BenutzerFachOrderByWithAggregationInput[]
    by: BenutzerFachScalarFieldEnum[] | BenutzerFachScalarFieldEnum
    having?: BenutzerFachScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BenutzerFachCountAggregateInputType | true
    _avg?: BenutzerFachAvgAggregateInputType
    _sum?: BenutzerFachSumAggregateInputType
    _min?: BenutzerFachMinAggregateInputType
    _max?: BenutzerFachMaxAggregateInputType
  }

  export type BenutzerFachGroupByOutputType = {
    id: number
    benutzer_id: number
    fach_id: number
    _count: BenutzerFachCountAggregateOutputType | null
    _avg: BenutzerFachAvgAggregateOutputType | null
    _sum: BenutzerFachSumAggregateOutputType | null
    _min: BenutzerFachMinAggregateOutputType | null
    _max: BenutzerFachMaxAggregateOutputType | null
  }

  type GetBenutzerFachGroupByPayload<T extends BenutzerFachGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BenutzerFachGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BenutzerFachGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BenutzerFachGroupByOutputType[P]>
            : GetScalarType<T[P], BenutzerFachGroupByOutputType[P]>
        }
      >
    >


  export type BenutzerFachSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    benutzer_id?: boolean
    fach_id?: boolean
    benutzer?: boolean | BenutzerDefaultArgs<ExtArgs>
    fach?: boolean | FachDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["benutzerFach"]>



  export type BenutzerFachSelectScalar = {
    id?: boolean
    benutzer_id?: boolean
    fach_id?: boolean
  }

  export type BenutzerFachOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "benutzer_id" | "fach_id", ExtArgs["result"]["benutzerFach"]>
  export type BenutzerFachInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benutzer?: boolean | BenutzerDefaultArgs<ExtArgs>
    fach?: boolean | FachDefaultArgs<ExtArgs>
  }

  export type $BenutzerFachPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BenutzerFach"
    objects: {
      benutzer: Prisma.$BenutzerPayload<ExtArgs>
      fach: Prisma.$FachPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      benutzer_id: number
      fach_id: number
    }, ExtArgs["result"]["benutzerFach"]>
    composites: {}
  }

  type BenutzerFachGetPayload<S extends boolean | null | undefined | BenutzerFachDefaultArgs> = $Result.GetResult<Prisma.$BenutzerFachPayload, S>

  type BenutzerFachCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BenutzerFachFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BenutzerFachCountAggregateInputType | true
    }

  export interface BenutzerFachDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BenutzerFach'], meta: { name: 'BenutzerFach' } }
    /**
     * Find zero or one BenutzerFach that matches the filter.
     * @param {BenutzerFachFindUniqueArgs} args - Arguments to find a BenutzerFach
     * @example
     * // Get one BenutzerFach
     * const benutzerFach = await prisma.benutzerFach.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BenutzerFachFindUniqueArgs>(args: SelectSubset<T, BenutzerFachFindUniqueArgs<ExtArgs>>): Prisma__BenutzerFachClient<$Result.GetResult<Prisma.$BenutzerFachPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BenutzerFach that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BenutzerFachFindUniqueOrThrowArgs} args - Arguments to find a BenutzerFach
     * @example
     * // Get one BenutzerFach
     * const benutzerFach = await prisma.benutzerFach.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BenutzerFachFindUniqueOrThrowArgs>(args: SelectSubset<T, BenutzerFachFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BenutzerFachClient<$Result.GetResult<Prisma.$BenutzerFachPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BenutzerFach that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerFachFindFirstArgs} args - Arguments to find a BenutzerFach
     * @example
     * // Get one BenutzerFach
     * const benutzerFach = await prisma.benutzerFach.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BenutzerFachFindFirstArgs>(args?: SelectSubset<T, BenutzerFachFindFirstArgs<ExtArgs>>): Prisma__BenutzerFachClient<$Result.GetResult<Prisma.$BenutzerFachPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BenutzerFach that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerFachFindFirstOrThrowArgs} args - Arguments to find a BenutzerFach
     * @example
     * // Get one BenutzerFach
     * const benutzerFach = await prisma.benutzerFach.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BenutzerFachFindFirstOrThrowArgs>(args?: SelectSubset<T, BenutzerFachFindFirstOrThrowArgs<ExtArgs>>): Prisma__BenutzerFachClient<$Result.GetResult<Prisma.$BenutzerFachPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BenutzerFaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerFachFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BenutzerFaches
     * const benutzerFaches = await prisma.benutzerFach.findMany()
     * 
     * // Get first 10 BenutzerFaches
     * const benutzerFaches = await prisma.benutzerFach.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const benutzerFachWithIdOnly = await prisma.benutzerFach.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BenutzerFachFindManyArgs>(args?: SelectSubset<T, BenutzerFachFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenutzerFachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BenutzerFach.
     * @param {BenutzerFachCreateArgs} args - Arguments to create a BenutzerFach.
     * @example
     * // Create one BenutzerFach
     * const BenutzerFach = await prisma.benutzerFach.create({
     *   data: {
     *     // ... data to create a BenutzerFach
     *   }
     * })
     * 
     */
    create<T extends BenutzerFachCreateArgs>(args: SelectSubset<T, BenutzerFachCreateArgs<ExtArgs>>): Prisma__BenutzerFachClient<$Result.GetResult<Prisma.$BenutzerFachPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BenutzerFaches.
     * @param {BenutzerFachCreateManyArgs} args - Arguments to create many BenutzerFaches.
     * @example
     * // Create many BenutzerFaches
     * const benutzerFach = await prisma.benutzerFach.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BenutzerFachCreateManyArgs>(args?: SelectSubset<T, BenutzerFachCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BenutzerFach.
     * @param {BenutzerFachDeleteArgs} args - Arguments to delete one BenutzerFach.
     * @example
     * // Delete one BenutzerFach
     * const BenutzerFach = await prisma.benutzerFach.delete({
     *   where: {
     *     // ... filter to delete one BenutzerFach
     *   }
     * })
     * 
     */
    delete<T extends BenutzerFachDeleteArgs>(args: SelectSubset<T, BenutzerFachDeleteArgs<ExtArgs>>): Prisma__BenutzerFachClient<$Result.GetResult<Prisma.$BenutzerFachPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BenutzerFach.
     * @param {BenutzerFachUpdateArgs} args - Arguments to update one BenutzerFach.
     * @example
     * // Update one BenutzerFach
     * const benutzerFach = await prisma.benutzerFach.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BenutzerFachUpdateArgs>(args: SelectSubset<T, BenutzerFachUpdateArgs<ExtArgs>>): Prisma__BenutzerFachClient<$Result.GetResult<Prisma.$BenutzerFachPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BenutzerFaches.
     * @param {BenutzerFachDeleteManyArgs} args - Arguments to filter BenutzerFaches to delete.
     * @example
     * // Delete a few BenutzerFaches
     * const { count } = await prisma.benutzerFach.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BenutzerFachDeleteManyArgs>(args?: SelectSubset<T, BenutzerFachDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BenutzerFaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerFachUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BenutzerFaches
     * const benutzerFach = await prisma.benutzerFach.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BenutzerFachUpdateManyArgs>(args: SelectSubset<T, BenutzerFachUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BenutzerFach.
     * @param {BenutzerFachUpsertArgs} args - Arguments to update or create a BenutzerFach.
     * @example
     * // Update or create a BenutzerFach
     * const benutzerFach = await prisma.benutzerFach.upsert({
     *   create: {
     *     // ... data to create a BenutzerFach
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BenutzerFach we want to update
     *   }
     * })
     */
    upsert<T extends BenutzerFachUpsertArgs>(args: SelectSubset<T, BenutzerFachUpsertArgs<ExtArgs>>): Prisma__BenutzerFachClient<$Result.GetResult<Prisma.$BenutzerFachPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BenutzerFaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerFachCountArgs} args - Arguments to filter BenutzerFaches to count.
     * @example
     * // Count the number of BenutzerFaches
     * const count = await prisma.benutzerFach.count({
     *   where: {
     *     // ... the filter for the BenutzerFaches we want to count
     *   }
     * })
    **/
    count<T extends BenutzerFachCountArgs>(
      args?: Subset<T, BenutzerFachCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BenutzerFachCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BenutzerFach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerFachAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BenutzerFachAggregateArgs>(args: Subset<T, BenutzerFachAggregateArgs>): Prisma.PrismaPromise<GetBenutzerFachAggregateType<T>>

    /**
     * Group by BenutzerFach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenutzerFachGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BenutzerFachGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BenutzerFachGroupByArgs['orderBy'] }
        : { orderBy?: BenutzerFachGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BenutzerFachGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBenutzerFachGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BenutzerFach model
   */
  readonly fields: BenutzerFachFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BenutzerFach.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BenutzerFachClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    benutzer<T extends BenutzerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BenutzerDefaultArgs<ExtArgs>>): Prisma__BenutzerClient<$Result.GetResult<Prisma.$BenutzerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fach<T extends FachDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FachDefaultArgs<ExtArgs>>): Prisma__FachClient<$Result.GetResult<Prisma.$FachPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BenutzerFach model
   */
  interface BenutzerFachFieldRefs {
    readonly id: FieldRef<"BenutzerFach", 'Int'>
    readonly benutzer_id: FieldRef<"BenutzerFach", 'Int'>
    readonly fach_id: FieldRef<"BenutzerFach", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BenutzerFach findUnique
   */
  export type BenutzerFachFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerFach
     */
    select?: BenutzerFachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerFach
     */
    omit?: BenutzerFachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerFachInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerFach to fetch.
     */
    where: BenutzerFachWhereUniqueInput
  }

  /**
   * BenutzerFach findUniqueOrThrow
   */
  export type BenutzerFachFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerFach
     */
    select?: BenutzerFachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerFach
     */
    omit?: BenutzerFachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerFachInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerFach to fetch.
     */
    where: BenutzerFachWhereUniqueInput
  }

  /**
   * BenutzerFach findFirst
   */
  export type BenutzerFachFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerFach
     */
    select?: BenutzerFachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerFach
     */
    omit?: BenutzerFachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerFachInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerFach to fetch.
     */
    where?: BenutzerFachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenutzerFaches to fetch.
     */
    orderBy?: BenutzerFachOrderByWithRelationInput | BenutzerFachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BenutzerFaches.
     */
    cursor?: BenutzerFachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenutzerFaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenutzerFaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BenutzerFaches.
     */
    distinct?: BenutzerFachScalarFieldEnum | BenutzerFachScalarFieldEnum[]
  }

  /**
   * BenutzerFach findFirstOrThrow
   */
  export type BenutzerFachFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerFach
     */
    select?: BenutzerFachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerFach
     */
    omit?: BenutzerFachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerFachInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerFach to fetch.
     */
    where?: BenutzerFachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenutzerFaches to fetch.
     */
    orderBy?: BenutzerFachOrderByWithRelationInput | BenutzerFachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BenutzerFaches.
     */
    cursor?: BenutzerFachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenutzerFaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenutzerFaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BenutzerFaches.
     */
    distinct?: BenutzerFachScalarFieldEnum | BenutzerFachScalarFieldEnum[]
  }

  /**
   * BenutzerFach findMany
   */
  export type BenutzerFachFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerFach
     */
    select?: BenutzerFachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerFach
     */
    omit?: BenutzerFachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerFachInclude<ExtArgs> | null
    /**
     * Filter, which BenutzerFaches to fetch.
     */
    where?: BenutzerFachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenutzerFaches to fetch.
     */
    orderBy?: BenutzerFachOrderByWithRelationInput | BenutzerFachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BenutzerFaches.
     */
    cursor?: BenutzerFachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenutzerFaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenutzerFaches.
     */
    skip?: number
    distinct?: BenutzerFachScalarFieldEnum | BenutzerFachScalarFieldEnum[]
  }

  /**
   * BenutzerFach create
   */
  export type BenutzerFachCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerFach
     */
    select?: BenutzerFachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerFach
     */
    omit?: BenutzerFachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerFachInclude<ExtArgs> | null
    /**
     * The data needed to create a BenutzerFach.
     */
    data: XOR<BenutzerFachCreateInput, BenutzerFachUncheckedCreateInput>
  }

  /**
   * BenutzerFach createMany
   */
  export type BenutzerFachCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BenutzerFaches.
     */
    data: BenutzerFachCreateManyInput | BenutzerFachCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BenutzerFach update
   */
  export type BenutzerFachUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerFach
     */
    select?: BenutzerFachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerFach
     */
    omit?: BenutzerFachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerFachInclude<ExtArgs> | null
    /**
     * The data needed to update a BenutzerFach.
     */
    data: XOR<BenutzerFachUpdateInput, BenutzerFachUncheckedUpdateInput>
    /**
     * Choose, which BenutzerFach to update.
     */
    where: BenutzerFachWhereUniqueInput
  }

  /**
   * BenutzerFach updateMany
   */
  export type BenutzerFachUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BenutzerFaches.
     */
    data: XOR<BenutzerFachUpdateManyMutationInput, BenutzerFachUncheckedUpdateManyInput>
    /**
     * Filter which BenutzerFaches to update
     */
    where?: BenutzerFachWhereInput
    /**
     * Limit how many BenutzerFaches to update.
     */
    limit?: number
  }

  /**
   * BenutzerFach upsert
   */
  export type BenutzerFachUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerFach
     */
    select?: BenutzerFachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerFach
     */
    omit?: BenutzerFachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerFachInclude<ExtArgs> | null
    /**
     * The filter to search for the BenutzerFach to update in case it exists.
     */
    where: BenutzerFachWhereUniqueInput
    /**
     * In case the BenutzerFach found by the `where` argument doesn't exist, create a new BenutzerFach with this data.
     */
    create: XOR<BenutzerFachCreateInput, BenutzerFachUncheckedCreateInput>
    /**
     * In case the BenutzerFach was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BenutzerFachUpdateInput, BenutzerFachUncheckedUpdateInput>
  }

  /**
   * BenutzerFach delete
   */
  export type BenutzerFachDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerFach
     */
    select?: BenutzerFachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerFach
     */
    omit?: BenutzerFachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerFachInclude<ExtArgs> | null
    /**
     * Filter which BenutzerFach to delete.
     */
    where: BenutzerFachWhereUniqueInput
  }

  /**
   * BenutzerFach deleteMany
   */
  export type BenutzerFachDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BenutzerFaches to delete
     */
    where?: BenutzerFachWhereInput
    /**
     * Limit how many BenutzerFaches to delete.
     */
    limit?: number
  }

  /**
   * BenutzerFach without action
   */
  export type BenutzerFachDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenutzerFach
     */
    select?: BenutzerFachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BenutzerFach
     */
    omit?: BenutzerFachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BenutzerFachInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BenutzerScalarFieldEnum: {
    id: 'id',
    vorname: 'vorname',
    nachname: 'nachname',
    email: 'email',
    passwort_hash: 'passwort_hash',
    erstellt_am: 'erstellt_am',
    aktiv: 'aktiv'
  };

  export type BenutzerScalarFieldEnum = (typeof BenutzerScalarFieldEnum)[keyof typeof BenutzerScalarFieldEnum]


  export const RolleScalarFieldEnum: {
    id: 'id',
    bezeichnung: 'bezeichnung',
    beschreibung: 'beschreibung'
  };

  export type RolleScalarFieldEnum = (typeof RolleScalarFieldEnum)[keyof typeof RolleScalarFieldEnum]


  export const BenutzerRolleScalarFieldEnum: {
    id: 'id',
    benutzer_id: 'benutzer_id',
    rolle_id: 'rolle_id'
  };

  export type BenutzerRolleScalarFieldEnum = (typeof BenutzerRolleScalarFieldEnum)[keyof typeof BenutzerRolleScalarFieldEnum]


  export const KlasseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    jahrgang: 'jahrgang'
  };

  export type KlasseScalarFieldEnum = (typeof KlasseScalarFieldEnum)[keyof typeof KlasseScalarFieldEnum]


  export const BenutzerKlasseScalarFieldEnum: {
    id: 'id',
    benutzer_id: 'benutzer_id',
    klasse_id: 'klasse_id'
  };

  export type BenutzerKlasseScalarFieldEnum = (typeof BenutzerKlasseScalarFieldEnum)[keyof typeof BenutzerKlasseScalarFieldEnum]


  export const FachScalarFieldEnum: {
    id: 'id',
    name: 'name',
    kuerzel: 'kuerzel'
  };

  export type FachScalarFieldEnum = (typeof FachScalarFieldEnum)[keyof typeof FachScalarFieldEnum]


  export const BenutzerFachScalarFieldEnum: {
    id: 'id',
    benutzer_id: 'benutzer_id',
    fach_id: 'fach_id'
  };

  export type BenutzerFachScalarFieldEnum = (typeof BenutzerFachScalarFieldEnum)[keyof typeof BenutzerFachScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const BenutzerOrderByRelevanceFieldEnum: {
    vorname: 'vorname',
    nachname: 'nachname',
    email: 'email',
    passwort_hash: 'passwort_hash'
  };

  export type BenutzerOrderByRelevanceFieldEnum = (typeof BenutzerOrderByRelevanceFieldEnum)[keyof typeof BenutzerOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const RolleOrderByRelevanceFieldEnum: {
    bezeichnung: 'bezeichnung',
    beschreibung: 'beschreibung'
  };

  export type RolleOrderByRelevanceFieldEnum = (typeof RolleOrderByRelevanceFieldEnum)[keyof typeof RolleOrderByRelevanceFieldEnum]


  export const KlasseOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type KlasseOrderByRelevanceFieldEnum = (typeof KlasseOrderByRelevanceFieldEnum)[keyof typeof KlasseOrderByRelevanceFieldEnum]


  export const FachOrderByRelevanceFieldEnum: {
    name: 'name',
    kuerzel: 'kuerzel'
  };

  export type FachOrderByRelevanceFieldEnum = (typeof FachOrderByRelevanceFieldEnum)[keyof typeof FachOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type BenutzerWhereInput = {
    AND?: BenutzerWhereInput | BenutzerWhereInput[]
    OR?: BenutzerWhereInput[]
    NOT?: BenutzerWhereInput | BenutzerWhereInput[]
    id?: IntFilter<"Benutzer"> | number
    vorname?: StringFilter<"Benutzer"> | string
    nachname?: StringFilter<"Benutzer"> | string
    email?: StringFilter<"Benutzer"> | string
    passwort_hash?: StringFilter<"Benutzer"> | string
    erstellt_am?: DateTimeFilter<"Benutzer"> | Date | string
    aktiv?: BoolFilter<"Benutzer"> | boolean
    benutzer_rollen?: BenutzerRolleListRelationFilter
    benutzer_klassen?: BenutzerKlasseListRelationFilter
    benutzer_faecher?: BenutzerFachListRelationFilter
  }

  export type BenutzerOrderByWithRelationInput = {
    id?: SortOrder
    vorname?: SortOrder
    nachname?: SortOrder
    email?: SortOrder
    passwort_hash?: SortOrder
    erstellt_am?: SortOrder
    aktiv?: SortOrder
    benutzer_rollen?: BenutzerRolleOrderByRelationAggregateInput
    benutzer_klassen?: BenutzerKlasseOrderByRelationAggregateInput
    benutzer_faecher?: BenutzerFachOrderByRelationAggregateInput
    _relevance?: BenutzerOrderByRelevanceInput
  }

  export type BenutzerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: BenutzerWhereInput | BenutzerWhereInput[]
    OR?: BenutzerWhereInput[]
    NOT?: BenutzerWhereInput | BenutzerWhereInput[]
    vorname?: StringFilter<"Benutzer"> | string
    nachname?: StringFilter<"Benutzer"> | string
    passwort_hash?: StringFilter<"Benutzer"> | string
    erstellt_am?: DateTimeFilter<"Benutzer"> | Date | string
    aktiv?: BoolFilter<"Benutzer"> | boolean
    benutzer_rollen?: BenutzerRolleListRelationFilter
    benutzer_klassen?: BenutzerKlasseListRelationFilter
    benutzer_faecher?: BenutzerFachListRelationFilter
  }, "id" | "email">

  export type BenutzerOrderByWithAggregationInput = {
    id?: SortOrder
    vorname?: SortOrder
    nachname?: SortOrder
    email?: SortOrder
    passwort_hash?: SortOrder
    erstellt_am?: SortOrder
    aktiv?: SortOrder
    _count?: BenutzerCountOrderByAggregateInput
    _avg?: BenutzerAvgOrderByAggregateInput
    _max?: BenutzerMaxOrderByAggregateInput
    _min?: BenutzerMinOrderByAggregateInput
    _sum?: BenutzerSumOrderByAggregateInput
  }

  export type BenutzerScalarWhereWithAggregatesInput = {
    AND?: BenutzerScalarWhereWithAggregatesInput | BenutzerScalarWhereWithAggregatesInput[]
    OR?: BenutzerScalarWhereWithAggregatesInput[]
    NOT?: BenutzerScalarWhereWithAggregatesInput | BenutzerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Benutzer"> | number
    vorname?: StringWithAggregatesFilter<"Benutzer"> | string
    nachname?: StringWithAggregatesFilter<"Benutzer"> | string
    email?: StringWithAggregatesFilter<"Benutzer"> | string
    passwort_hash?: StringWithAggregatesFilter<"Benutzer"> | string
    erstellt_am?: DateTimeWithAggregatesFilter<"Benutzer"> | Date | string
    aktiv?: BoolWithAggregatesFilter<"Benutzer"> | boolean
  }

  export type RolleWhereInput = {
    AND?: RolleWhereInput | RolleWhereInput[]
    OR?: RolleWhereInput[]
    NOT?: RolleWhereInput | RolleWhereInput[]
    id?: IntFilter<"Rolle"> | number
    bezeichnung?: StringFilter<"Rolle"> | string
    beschreibung?: StringNullableFilter<"Rolle"> | string | null
    benutzer_rollen?: BenutzerRolleListRelationFilter
  }

  export type RolleOrderByWithRelationInput = {
    id?: SortOrder
    bezeichnung?: SortOrder
    beschreibung?: SortOrderInput | SortOrder
    benutzer_rollen?: BenutzerRolleOrderByRelationAggregateInput
    _relevance?: RolleOrderByRelevanceInput
  }

  export type RolleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bezeichnung?: string
    AND?: RolleWhereInput | RolleWhereInput[]
    OR?: RolleWhereInput[]
    NOT?: RolleWhereInput | RolleWhereInput[]
    beschreibung?: StringNullableFilter<"Rolle"> | string | null
    benutzer_rollen?: BenutzerRolleListRelationFilter
  }, "id" | "bezeichnung">

  export type RolleOrderByWithAggregationInput = {
    id?: SortOrder
    bezeichnung?: SortOrder
    beschreibung?: SortOrderInput | SortOrder
    _count?: RolleCountOrderByAggregateInput
    _avg?: RolleAvgOrderByAggregateInput
    _max?: RolleMaxOrderByAggregateInput
    _min?: RolleMinOrderByAggregateInput
    _sum?: RolleSumOrderByAggregateInput
  }

  export type RolleScalarWhereWithAggregatesInput = {
    AND?: RolleScalarWhereWithAggregatesInput | RolleScalarWhereWithAggregatesInput[]
    OR?: RolleScalarWhereWithAggregatesInput[]
    NOT?: RolleScalarWhereWithAggregatesInput | RolleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rolle"> | number
    bezeichnung?: StringWithAggregatesFilter<"Rolle"> | string
    beschreibung?: StringNullableWithAggregatesFilter<"Rolle"> | string | null
  }

  export type BenutzerRolleWhereInput = {
    AND?: BenutzerRolleWhereInput | BenutzerRolleWhereInput[]
    OR?: BenutzerRolleWhereInput[]
    NOT?: BenutzerRolleWhereInput | BenutzerRolleWhereInput[]
    id?: IntFilter<"BenutzerRolle"> | number
    benutzer_id?: IntFilter<"BenutzerRolle"> | number
    rolle_id?: IntFilter<"BenutzerRolle"> | number
    benutzer?: XOR<BenutzerScalarRelationFilter, BenutzerWhereInput>
    rolle?: XOR<RolleScalarRelationFilter, RolleWhereInput>
  }

  export type BenutzerRolleOrderByWithRelationInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    rolle_id?: SortOrder
    benutzer?: BenutzerOrderByWithRelationInput
    rolle?: RolleOrderByWithRelationInput
  }

  export type BenutzerRolleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    benutzer_id_rolle_id?: BenutzerRolleBenutzer_idRolle_idCompoundUniqueInput
    AND?: BenutzerRolleWhereInput | BenutzerRolleWhereInput[]
    OR?: BenutzerRolleWhereInput[]
    NOT?: BenutzerRolleWhereInput | BenutzerRolleWhereInput[]
    benutzer_id?: IntFilter<"BenutzerRolle"> | number
    rolle_id?: IntFilter<"BenutzerRolle"> | number
    benutzer?: XOR<BenutzerScalarRelationFilter, BenutzerWhereInput>
    rolle?: XOR<RolleScalarRelationFilter, RolleWhereInput>
  }, "id" | "benutzer_id_rolle_id">

  export type BenutzerRolleOrderByWithAggregationInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    rolle_id?: SortOrder
    _count?: BenutzerRolleCountOrderByAggregateInput
    _avg?: BenutzerRolleAvgOrderByAggregateInput
    _max?: BenutzerRolleMaxOrderByAggregateInput
    _min?: BenutzerRolleMinOrderByAggregateInput
    _sum?: BenutzerRolleSumOrderByAggregateInput
  }

  export type BenutzerRolleScalarWhereWithAggregatesInput = {
    AND?: BenutzerRolleScalarWhereWithAggregatesInput | BenutzerRolleScalarWhereWithAggregatesInput[]
    OR?: BenutzerRolleScalarWhereWithAggregatesInput[]
    NOT?: BenutzerRolleScalarWhereWithAggregatesInput | BenutzerRolleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BenutzerRolle"> | number
    benutzer_id?: IntWithAggregatesFilter<"BenutzerRolle"> | number
    rolle_id?: IntWithAggregatesFilter<"BenutzerRolle"> | number
  }

  export type KlasseWhereInput = {
    AND?: KlasseWhereInput | KlasseWhereInput[]
    OR?: KlasseWhereInput[]
    NOT?: KlasseWhereInput | KlasseWhereInput[]
    id?: IntFilter<"Klasse"> | number
    name?: StringFilter<"Klasse"> | string
    jahrgang?: IntFilter<"Klasse"> | number
    benutzer_klassen?: BenutzerKlasseListRelationFilter
  }

  export type KlasseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    jahrgang?: SortOrder
    benutzer_klassen?: BenutzerKlasseOrderByRelationAggregateInput
    _relevance?: KlasseOrderByRelevanceInput
  }

  export type KlasseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_jahrgang?: KlasseNameJahrgangCompoundUniqueInput
    AND?: KlasseWhereInput | KlasseWhereInput[]
    OR?: KlasseWhereInput[]
    NOT?: KlasseWhereInput | KlasseWhereInput[]
    name?: StringFilter<"Klasse"> | string
    jahrgang?: IntFilter<"Klasse"> | number
    benutzer_klassen?: BenutzerKlasseListRelationFilter
  }, "id" | "name_jahrgang">

  export type KlasseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    jahrgang?: SortOrder
    _count?: KlasseCountOrderByAggregateInput
    _avg?: KlasseAvgOrderByAggregateInput
    _max?: KlasseMaxOrderByAggregateInput
    _min?: KlasseMinOrderByAggregateInput
    _sum?: KlasseSumOrderByAggregateInput
  }

  export type KlasseScalarWhereWithAggregatesInput = {
    AND?: KlasseScalarWhereWithAggregatesInput | KlasseScalarWhereWithAggregatesInput[]
    OR?: KlasseScalarWhereWithAggregatesInput[]
    NOT?: KlasseScalarWhereWithAggregatesInput | KlasseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Klasse"> | number
    name?: StringWithAggregatesFilter<"Klasse"> | string
    jahrgang?: IntWithAggregatesFilter<"Klasse"> | number
  }

  export type BenutzerKlasseWhereInput = {
    AND?: BenutzerKlasseWhereInput | BenutzerKlasseWhereInput[]
    OR?: BenutzerKlasseWhereInput[]
    NOT?: BenutzerKlasseWhereInput | BenutzerKlasseWhereInput[]
    id?: IntFilter<"BenutzerKlasse"> | number
    benutzer_id?: IntFilter<"BenutzerKlasse"> | number
    klasse_id?: IntFilter<"BenutzerKlasse"> | number
    klasse?: XOR<KlasseScalarRelationFilter, KlasseWhereInput>
    benutzer?: XOR<BenutzerScalarRelationFilter, BenutzerWhereInput>
  }

  export type BenutzerKlasseOrderByWithRelationInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    klasse_id?: SortOrder
    klasse?: KlasseOrderByWithRelationInput
    benutzer?: BenutzerOrderByWithRelationInput
  }

  export type BenutzerKlasseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    benutzer_id_klasse_id?: BenutzerKlasseBenutzer_idKlasse_idCompoundUniqueInput
    AND?: BenutzerKlasseWhereInput | BenutzerKlasseWhereInput[]
    OR?: BenutzerKlasseWhereInput[]
    NOT?: BenutzerKlasseWhereInput | BenutzerKlasseWhereInput[]
    benutzer_id?: IntFilter<"BenutzerKlasse"> | number
    klasse_id?: IntFilter<"BenutzerKlasse"> | number
    klasse?: XOR<KlasseScalarRelationFilter, KlasseWhereInput>
    benutzer?: XOR<BenutzerScalarRelationFilter, BenutzerWhereInput>
  }, "id" | "benutzer_id_klasse_id">

  export type BenutzerKlasseOrderByWithAggregationInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    klasse_id?: SortOrder
    _count?: BenutzerKlasseCountOrderByAggregateInput
    _avg?: BenutzerKlasseAvgOrderByAggregateInput
    _max?: BenutzerKlasseMaxOrderByAggregateInput
    _min?: BenutzerKlasseMinOrderByAggregateInput
    _sum?: BenutzerKlasseSumOrderByAggregateInput
  }

  export type BenutzerKlasseScalarWhereWithAggregatesInput = {
    AND?: BenutzerKlasseScalarWhereWithAggregatesInput | BenutzerKlasseScalarWhereWithAggregatesInput[]
    OR?: BenutzerKlasseScalarWhereWithAggregatesInput[]
    NOT?: BenutzerKlasseScalarWhereWithAggregatesInput | BenutzerKlasseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BenutzerKlasse"> | number
    benutzer_id?: IntWithAggregatesFilter<"BenutzerKlasse"> | number
    klasse_id?: IntWithAggregatesFilter<"BenutzerKlasse"> | number
  }

  export type FachWhereInput = {
    AND?: FachWhereInput | FachWhereInput[]
    OR?: FachWhereInput[]
    NOT?: FachWhereInput | FachWhereInput[]
    id?: IntFilter<"Fach"> | number
    name?: StringFilter<"Fach"> | string
    kuerzel?: StringFilter<"Fach"> | string
    benutzer_faecher?: BenutzerFachListRelationFilter
  }

  export type FachOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    kuerzel?: SortOrder
    benutzer_faecher?: BenutzerFachOrderByRelationAggregateInput
    _relevance?: FachOrderByRelevanceInput
  }

  export type FachWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    kuerzel?: string
    AND?: FachWhereInput | FachWhereInput[]
    OR?: FachWhereInput[]
    NOT?: FachWhereInput | FachWhereInput[]
    name?: StringFilter<"Fach"> | string
    benutzer_faecher?: BenutzerFachListRelationFilter
  }, "id" | "kuerzel">

  export type FachOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    kuerzel?: SortOrder
    _count?: FachCountOrderByAggregateInput
    _avg?: FachAvgOrderByAggregateInput
    _max?: FachMaxOrderByAggregateInput
    _min?: FachMinOrderByAggregateInput
    _sum?: FachSumOrderByAggregateInput
  }

  export type FachScalarWhereWithAggregatesInput = {
    AND?: FachScalarWhereWithAggregatesInput | FachScalarWhereWithAggregatesInput[]
    OR?: FachScalarWhereWithAggregatesInput[]
    NOT?: FachScalarWhereWithAggregatesInput | FachScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Fach"> | number
    name?: StringWithAggregatesFilter<"Fach"> | string
    kuerzel?: StringWithAggregatesFilter<"Fach"> | string
  }

  export type BenutzerFachWhereInput = {
    AND?: BenutzerFachWhereInput | BenutzerFachWhereInput[]
    OR?: BenutzerFachWhereInput[]
    NOT?: BenutzerFachWhereInput | BenutzerFachWhereInput[]
    id?: IntFilter<"BenutzerFach"> | number
    benutzer_id?: IntFilter<"BenutzerFach"> | number
    fach_id?: IntFilter<"BenutzerFach"> | number
    benutzer?: XOR<BenutzerScalarRelationFilter, BenutzerWhereInput>
    fach?: XOR<FachScalarRelationFilter, FachWhereInput>
  }

  export type BenutzerFachOrderByWithRelationInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    fach_id?: SortOrder
    benutzer?: BenutzerOrderByWithRelationInput
    fach?: FachOrderByWithRelationInput
  }

  export type BenutzerFachWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    benutzer_id_fach_id?: BenutzerFachBenutzer_idFach_idCompoundUniqueInput
    AND?: BenutzerFachWhereInput | BenutzerFachWhereInput[]
    OR?: BenutzerFachWhereInput[]
    NOT?: BenutzerFachWhereInput | BenutzerFachWhereInput[]
    benutzer_id?: IntFilter<"BenutzerFach"> | number
    fach_id?: IntFilter<"BenutzerFach"> | number
    benutzer?: XOR<BenutzerScalarRelationFilter, BenutzerWhereInput>
    fach?: XOR<FachScalarRelationFilter, FachWhereInput>
  }, "id" | "benutzer_id_fach_id">

  export type BenutzerFachOrderByWithAggregationInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    fach_id?: SortOrder
    _count?: BenutzerFachCountOrderByAggregateInput
    _avg?: BenutzerFachAvgOrderByAggregateInput
    _max?: BenutzerFachMaxOrderByAggregateInput
    _min?: BenutzerFachMinOrderByAggregateInput
    _sum?: BenutzerFachSumOrderByAggregateInput
  }

  export type BenutzerFachScalarWhereWithAggregatesInput = {
    AND?: BenutzerFachScalarWhereWithAggregatesInput | BenutzerFachScalarWhereWithAggregatesInput[]
    OR?: BenutzerFachScalarWhereWithAggregatesInput[]
    NOT?: BenutzerFachScalarWhereWithAggregatesInput | BenutzerFachScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BenutzerFach"> | number
    benutzer_id?: IntWithAggregatesFilter<"BenutzerFach"> | number
    fach_id?: IntWithAggregatesFilter<"BenutzerFach"> | number
  }

  export type BenutzerCreateInput = {
    vorname: string
    nachname: string
    email: string
    passwort_hash: string
    erstellt_am?: Date | string
    aktiv?: boolean
    benutzer_rollen?: BenutzerRolleCreateNestedManyWithoutBenutzerInput
    benutzer_klassen?: BenutzerKlasseCreateNestedManyWithoutBenutzerInput
    benutzer_faecher?: BenutzerFachCreateNestedManyWithoutBenutzerInput
  }

  export type BenutzerUncheckedCreateInput = {
    id?: number
    vorname: string
    nachname: string
    email: string
    passwort_hash: string
    erstellt_am?: Date | string
    aktiv?: boolean
    benutzer_rollen?: BenutzerRolleUncheckedCreateNestedManyWithoutBenutzerInput
    benutzer_klassen?: BenutzerKlasseUncheckedCreateNestedManyWithoutBenutzerInput
    benutzer_faecher?: BenutzerFachUncheckedCreateNestedManyWithoutBenutzerInput
  }

  export type BenutzerUpdateInput = {
    vorname?: StringFieldUpdateOperationsInput | string
    nachname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwort_hash?: StringFieldUpdateOperationsInput | string
    erstellt_am?: DateTimeFieldUpdateOperationsInput | Date | string
    aktiv?: BoolFieldUpdateOperationsInput | boolean
    benutzer_rollen?: BenutzerRolleUpdateManyWithoutBenutzerNestedInput
    benutzer_klassen?: BenutzerKlasseUpdateManyWithoutBenutzerNestedInput
    benutzer_faecher?: BenutzerFachUpdateManyWithoutBenutzerNestedInput
  }

  export type BenutzerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vorname?: StringFieldUpdateOperationsInput | string
    nachname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwort_hash?: StringFieldUpdateOperationsInput | string
    erstellt_am?: DateTimeFieldUpdateOperationsInput | Date | string
    aktiv?: BoolFieldUpdateOperationsInput | boolean
    benutzer_rollen?: BenutzerRolleUncheckedUpdateManyWithoutBenutzerNestedInput
    benutzer_klassen?: BenutzerKlasseUncheckedUpdateManyWithoutBenutzerNestedInput
    benutzer_faecher?: BenutzerFachUncheckedUpdateManyWithoutBenutzerNestedInput
  }

  export type BenutzerCreateManyInput = {
    id?: number
    vorname: string
    nachname: string
    email: string
    passwort_hash: string
    erstellt_am?: Date | string
    aktiv?: boolean
  }

  export type BenutzerUpdateManyMutationInput = {
    vorname?: StringFieldUpdateOperationsInput | string
    nachname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwort_hash?: StringFieldUpdateOperationsInput | string
    erstellt_am?: DateTimeFieldUpdateOperationsInput | Date | string
    aktiv?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BenutzerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vorname?: StringFieldUpdateOperationsInput | string
    nachname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwort_hash?: StringFieldUpdateOperationsInput | string
    erstellt_am?: DateTimeFieldUpdateOperationsInput | Date | string
    aktiv?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolleCreateInput = {
    bezeichnung: string
    beschreibung?: string | null
    benutzer_rollen?: BenutzerRolleCreateNestedManyWithoutRolleInput
  }

  export type RolleUncheckedCreateInput = {
    id?: number
    bezeichnung: string
    beschreibung?: string | null
    benutzer_rollen?: BenutzerRolleUncheckedCreateNestedManyWithoutRolleInput
  }

  export type RolleUpdateInput = {
    bezeichnung?: StringFieldUpdateOperationsInput | string
    beschreibung?: NullableStringFieldUpdateOperationsInput | string | null
    benutzer_rollen?: BenutzerRolleUpdateManyWithoutRolleNestedInput
  }

  export type RolleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bezeichnung?: StringFieldUpdateOperationsInput | string
    beschreibung?: NullableStringFieldUpdateOperationsInput | string | null
    benutzer_rollen?: BenutzerRolleUncheckedUpdateManyWithoutRolleNestedInput
  }

  export type RolleCreateManyInput = {
    id?: number
    bezeichnung: string
    beschreibung?: string | null
  }

  export type RolleUpdateManyMutationInput = {
    bezeichnung?: StringFieldUpdateOperationsInput | string
    beschreibung?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bezeichnung?: StringFieldUpdateOperationsInput | string
    beschreibung?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BenutzerRolleCreateInput = {
    benutzer: BenutzerCreateNestedOneWithoutBenutzer_rollenInput
    rolle: RolleCreateNestedOneWithoutBenutzer_rollenInput
  }

  export type BenutzerRolleUncheckedCreateInput = {
    id?: number
    benutzer_id: number
    rolle_id: number
  }

  export type BenutzerRolleUpdateInput = {
    benutzer?: BenutzerUpdateOneRequiredWithoutBenutzer_rollenNestedInput
    rolle?: RolleUpdateOneRequiredWithoutBenutzer_rollenNestedInput
  }

  export type BenutzerRolleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    benutzer_id?: IntFieldUpdateOperationsInput | number
    rolle_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerRolleCreateManyInput = {
    id?: number
    benutzer_id: number
    rolle_id: number
  }

  export type BenutzerRolleUpdateManyMutationInput = {

  }

  export type BenutzerRolleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    benutzer_id?: IntFieldUpdateOperationsInput | number
    rolle_id?: IntFieldUpdateOperationsInput | number
  }

  export type KlasseCreateInput = {
    name: string
    jahrgang: number
    benutzer_klassen?: BenutzerKlasseCreateNestedManyWithoutKlasseInput
  }

  export type KlasseUncheckedCreateInput = {
    id?: number
    name: string
    jahrgang: number
    benutzer_klassen?: BenutzerKlasseUncheckedCreateNestedManyWithoutKlasseInput
  }

  export type KlasseUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    jahrgang?: IntFieldUpdateOperationsInput | number
    benutzer_klassen?: BenutzerKlasseUpdateManyWithoutKlasseNestedInput
  }

  export type KlasseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    jahrgang?: IntFieldUpdateOperationsInput | number
    benutzer_klassen?: BenutzerKlasseUncheckedUpdateManyWithoutKlasseNestedInput
  }

  export type KlasseCreateManyInput = {
    id?: number
    name: string
    jahrgang: number
  }

  export type KlasseUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    jahrgang?: IntFieldUpdateOperationsInput | number
  }

  export type KlasseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    jahrgang?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerKlasseCreateInput = {
    klasse: KlasseCreateNestedOneWithoutBenutzer_klassenInput
    benutzer: BenutzerCreateNestedOneWithoutBenutzer_klassenInput
  }

  export type BenutzerKlasseUncheckedCreateInput = {
    id?: number
    benutzer_id: number
    klasse_id: number
  }

  export type BenutzerKlasseUpdateInput = {
    klasse?: KlasseUpdateOneRequiredWithoutBenutzer_klassenNestedInput
    benutzer?: BenutzerUpdateOneRequiredWithoutBenutzer_klassenNestedInput
  }

  export type BenutzerKlasseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    benutzer_id?: IntFieldUpdateOperationsInput | number
    klasse_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerKlasseCreateManyInput = {
    id?: number
    benutzer_id: number
    klasse_id: number
  }

  export type BenutzerKlasseUpdateManyMutationInput = {

  }

  export type BenutzerKlasseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    benutzer_id?: IntFieldUpdateOperationsInput | number
    klasse_id?: IntFieldUpdateOperationsInput | number
  }

  export type FachCreateInput = {
    name: string
    kuerzel: string
    benutzer_faecher?: BenutzerFachCreateNestedManyWithoutFachInput
  }

  export type FachUncheckedCreateInput = {
    id?: number
    name: string
    kuerzel: string
    benutzer_faecher?: BenutzerFachUncheckedCreateNestedManyWithoutFachInput
  }

  export type FachUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    kuerzel?: StringFieldUpdateOperationsInput | string
    benutzer_faecher?: BenutzerFachUpdateManyWithoutFachNestedInput
  }

  export type FachUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    kuerzel?: StringFieldUpdateOperationsInput | string
    benutzer_faecher?: BenutzerFachUncheckedUpdateManyWithoutFachNestedInput
  }

  export type FachCreateManyInput = {
    id?: number
    name: string
    kuerzel: string
  }

  export type FachUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    kuerzel?: StringFieldUpdateOperationsInput | string
  }

  export type FachUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    kuerzel?: StringFieldUpdateOperationsInput | string
  }

  export type BenutzerFachCreateInput = {
    benutzer: BenutzerCreateNestedOneWithoutBenutzer_faecherInput
    fach: FachCreateNestedOneWithoutBenutzer_faecherInput
  }

  export type BenutzerFachUncheckedCreateInput = {
    id?: number
    benutzer_id: number
    fach_id: number
  }

  export type BenutzerFachUpdateInput = {
    benutzer?: BenutzerUpdateOneRequiredWithoutBenutzer_faecherNestedInput
    fach?: FachUpdateOneRequiredWithoutBenutzer_faecherNestedInput
  }

  export type BenutzerFachUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    benutzer_id?: IntFieldUpdateOperationsInput | number
    fach_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerFachCreateManyInput = {
    id?: number
    benutzer_id: number
    fach_id: number
  }

  export type BenutzerFachUpdateManyMutationInput = {

  }

  export type BenutzerFachUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    benutzer_id?: IntFieldUpdateOperationsInput | number
    fach_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BenutzerRolleListRelationFilter = {
    every?: BenutzerRolleWhereInput
    some?: BenutzerRolleWhereInput
    none?: BenutzerRolleWhereInput
  }

  export type BenutzerKlasseListRelationFilter = {
    every?: BenutzerKlasseWhereInput
    some?: BenutzerKlasseWhereInput
    none?: BenutzerKlasseWhereInput
  }

  export type BenutzerFachListRelationFilter = {
    every?: BenutzerFachWhereInput
    some?: BenutzerFachWhereInput
    none?: BenutzerFachWhereInput
  }

  export type BenutzerRolleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BenutzerKlasseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BenutzerFachOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BenutzerOrderByRelevanceInput = {
    fields: BenutzerOrderByRelevanceFieldEnum | BenutzerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BenutzerCountOrderByAggregateInput = {
    id?: SortOrder
    vorname?: SortOrder
    nachname?: SortOrder
    email?: SortOrder
    passwort_hash?: SortOrder
    erstellt_am?: SortOrder
    aktiv?: SortOrder
  }

  export type BenutzerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BenutzerMaxOrderByAggregateInput = {
    id?: SortOrder
    vorname?: SortOrder
    nachname?: SortOrder
    email?: SortOrder
    passwort_hash?: SortOrder
    erstellt_am?: SortOrder
    aktiv?: SortOrder
  }

  export type BenutzerMinOrderByAggregateInput = {
    id?: SortOrder
    vorname?: SortOrder
    nachname?: SortOrder
    email?: SortOrder
    passwort_hash?: SortOrder
    erstellt_am?: SortOrder
    aktiv?: SortOrder
  }

  export type BenutzerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RolleOrderByRelevanceInput = {
    fields: RolleOrderByRelevanceFieldEnum | RolleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RolleCountOrderByAggregateInput = {
    id?: SortOrder
    bezeichnung?: SortOrder
    beschreibung?: SortOrder
  }

  export type RolleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolleMaxOrderByAggregateInput = {
    id?: SortOrder
    bezeichnung?: SortOrder
    beschreibung?: SortOrder
  }

  export type RolleMinOrderByAggregateInput = {
    id?: SortOrder
    bezeichnung?: SortOrder
    beschreibung?: SortOrder
  }

  export type RolleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BenutzerScalarRelationFilter = {
    is?: BenutzerWhereInput
    isNot?: BenutzerWhereInput
  }

  export type RolleScalarRelationFilter = {
    is?: RolleWhereInput
    isNot?: RolleWhereInput
  }

  export type BenutzerRolleBenutzer_idRolle_idCompoundUniqueInput = {
    benutzer_id: number
    rolle_id: number
  }

  export type BenutzerRolleCountOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    rolle_id?: SortOrder
  }

  export type BenutzerRolleAvgOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    rolle_id?: SortOrder
  }

  export type BenutzerRolleMaxOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    rolle_id?: SortOrder
  }

  export type BenutzerRolleMinOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    rolle_id?: SortOrder
  }

  export type BenutzerRolleSumOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    rolle_id?: SortOrder
  }

  export type KlasseOrderByRelevanceInput = {
    fields: KlasseOrderByRelevanceFieldEnum | KlasseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type KlasseNameJahrgangCompoundUniqueInput = {
    name: string
    jahrgang: number
  }

  export type KlasseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    jahrgang?: SortOrder
  }

  export type KlasseAvgOrderByAggregateInput = {
    id?: SortOrder
    jahrgang?: SortOrder
  }

  export type KlasseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    jahrgang?: SortOrder
  }

  export type KlasseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    jahrgang?: SortOrder
  }

  export type KlasseSumOrderByAggregateInput = {
    id?: SortOrder
    jahrgang?: SortOrder
  }

  export type KlasseScalarRelationFilter = {
    is?: KlasseWhereInput
    isNot?: KlasseWhereInput
  }

  export type BenutzerKlasseBenutzer_idKlasse_idCompoundUniqueInput = {
    benutzer_id: number
    klasse_id: number
  }

  export type BenutzerKlasseCountOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    klasse_id?: SortOrder
  }

  export type BenutzerKlasseAvgOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    klasse_id?: SortOrder
  }

  export type BenutzerKlasseMaxOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    klasse_id?: SortOrder
  }

  export type BenutzerKlasseMinOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    klasse_id?: SortOrder
  }

  export type BenutzerKlasseSumOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    klasse_id?: SortOrder
  }

  export type FachOrderByRelevanceInput = {
    fields: FachOrderByRelevanceFieldEnum | FachOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FachCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    kuerzel?: SortOrder
  }

  export type FachAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FachMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    kuerzel?: SortOrder
  }

  export type FachMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    kuerzel?: SortOrder
  }

  export type FachSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FachScalarRelationFilter = {
    is?: FachWhereInput
    isNot?: FachWhereInput
  }

  export type BenutzerFachBenutzer_idFach_idCompoundUniqueInput = {
    benutzer_id: number
    fach_id: number
  }

  export type BenutzerFachCountOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    fach_id?: SortOrder
  }

  export type BenutzerFachAvgOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    fach_id?: SortOrder
  }

  export type BenutzerFachMaxOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    fach_id?: SortOrder
  }

  export type BenutzerFachMinOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    fach_id?: SortOrder
  }

  export type BenutzerFachSumOrderByAggregateInput = {
    id?: SortOrder
    benutzer_id?: SortOrder
    fach_id?: SortOrder
  }

  export type BenutzerRolleCreateNestedManyWithoutBenutzerInput = {
    create?: XOR<BenutzerRolleCreateWithoutBenutzerInput, BenutzerRolleUncheckedCreateWithoutBenutzerInput> | BenutzerRolleCreateWithoutBenutzerInput[] | BenutzerRolleUncheckedCreateWithoutBenutzerInput[]
    connectOrCreate?: BenutzerRolleCreateOrConnectWithoutBenutzerInput | BenutzerRolleCreateOrConnectWithoutBenutzerInput[]
    createMany?: BenutzerRolleCreateManyBenutzerInputEnvelope
    connect?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
  }

  export type BenutzerKlasseCreateNestedManyWithoutBenutzerInput = {
    create?: XOR<BenutzerKlasseCreateWithoutBenutzerInput, BenutzerKlasseUncheckedCreateWithoutBenutzerInput> | BenutzerKlasseCreateWithoutBenutzerInput[] | BenutzerKlasseUncheckedCreateWithoutBenutzerInput[]
    connectOrCreate?: BenutzerKlasseCreateOrConnectWithoutBenutzerInput | BenutzerKlasseCreateOrConnectWithoutBenutzerInput[]
    createMany?: BenutzerKlasseCreateManyBenutzerInputEnvelope
    connect?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
  }

  export type BenutzerFachCreateNestedManyWithoutBenutzerInput = {
    create?: XOR<BenutzerFachCreateWithoutBenutzerInput, BenutzerFachUncheckedCreateWithoutBenutzerInput> | BenutzerFachCreateWithoutBenutzerInput[] | BenutzerFachUncheckedCreateWithoutBenutzerInput[]
    connectOrCreate?: BenutzerFachCreateOrConnectWithoutBenutzerInput | BenutzerFachCreateOrConnectWithoutBenutzerInput[]
    createMany?: BenutzerFachCreateManyBenutzerInputEnvelope
    connect?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
  }

  export type BenutzerRolleUncheckedCreateNestedManyWithoutBenutzerInput = {
    create?: XOR<BenutzerRolleCreateWithoutBenutzerInput, BenutzerRolleUncheckedCreateWithoutBenutzerInput> | BenutzerRolleCreateWithoutBenutzerInput[] | BenutzerRolleUncheckedCreateWithoutBenutzerInput[]
    connectOrCreate?: BenutzerRolleCreateOrConnectWithoutBenutzerInput | BenutzerRolleCreateOrConnectWithoutBenutzerInput[]
    createMany?: BenutzerRolleCreateManyBenutzerInputEnvelope
    connect?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
  }

  export type BenutzerKlasseUncheckedCreateNestedManyWithoutBenutzerInput = {
    create?: XOR<BenutzerKlasseCreateWithoutBenutzerInput, BenutzerKlasseUncheckedCreateWithoutBenutzerInput> | BenutzerKlasseCreateWithoutBenutzerInput[] | BenutzerKlasseUncheckedCreateWithoutBenutzerInput[]
    connectOrCreate?: BenutzerKlasseCreateOrConnectWithoutBenutzerInput | BenutzerKlasseCreateOrConnectWithoutBenutzerInput[]
    createMany?: BenutzerKlasseCreateManyBenutzerInputEnvelope
    connect?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
  }

  export type BenutzerFachUncheckedCreateNestedManyWithoutBenutzerInput = {
    create?: XOR<BenutzerFachCreateWithoutBenutzerInput, BenutzerFachUncheckedCreateWithoutBenutzerInput> | BenutzerFachCreateWithoutBenutzerInput[] | BenutzerFachUncheckedCreateWithoutBenutzerInput[]
    connectOrCreate?: BenutzerFachCreateOrConnectWithoutBenutzerInput | BenutzerFachCreateOrConnectWithoutBenutzerInput[]
    createMany?: BenutzerFachCreateManyBenutzerInputEnvelope
    connect?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BenutzerRolleUpdateManyWithoutBenutzerNestedInput = {
    create?: XOR<BenutzerRolleCreateWithoutBenutzerInput, BenutzerRolleUncheckedCreateWithoutBenutzerInput> | BenutzerRolleCreateWithoutBenutzerInput[] | BenutzerRolleUncheckedCreateWithoutBenutzerInput[]
    connectOrCreate?: BenutzerRolleCreateOrConnectWithoutBenutzerInput | BenutzerRolleCreateOrConnectWithoutBenutzerInput[]
    upsert?: BenutzerRolleUpsertWithWhereUniqueWithoutBenutzerInput | BenutzerRolleUpsertWithWhereUniqueWithoutBenutzerInput[]
    createMany?: BenutzerRolleCreateManyBenutzerInputEnvelope
    set?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    disconnect?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    delete?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    connect?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    update?: BenutzerRolleUpdateWithWhereUniqueWithoutBenutzerInput | BenutzerRolleUpdateWithWhereUniqueWithoutBenutzerInput[]
    updateMany?: BenutzerRolleUpdateManyWithWhereWithoutBenutzerInput | BenutzerRolleUpdateManyWithWhereWithoutBenutzerInput[]
    deleteMany?: BenutzerRolleScalarWhereInput | BenutzerRolleScalarWhereInput[]
  }

  export type BenutzerKlasseUpdateManyWithoutBenutzerNestedInput = {
    create?: XOR<BenutzerKlasseCreateWithoutBenutzerInput, BenutzerKlasseUncheckedCreateWithoutBenutzerInput> | BenutzerKlasseCreateWithoutBenutzerInput[] | BenutzerKlasseUncheckedCreateWithoutBenutzerInput[]
    connectOrCreate?: BenutzerKlasseCreateOrConnectWithoutBenutzerInput | BenutzerKlasseCreateOrConnectWithoutBenutzerInput[]
    upsert?: BenutzerKlasseUpsertWithWhereUniqueWithoutBenutzerInput | BenutzerKlasseUpsertWithWhereUniqueWithoutBenutzerInput[]
    createMany?: BenutzerKlasseCreateManyBenutzerInputEnvelope
    set?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    disconnect?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    delete?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    connect?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    update?: BenutzerKlasseUpdateWithWhereUniqueWithoutBenutzerInput | BenutzerKlasseUpdateWithWhereUniqueWithoutBenutzerInput[]
    updateMany?: BenutzerKlasseUpdateManyWithWhereWithoutBenutzerInput | BenutzerKlasseUpdateManyWithWhereWithoutBenutzerInput[]
    deleteMany?: BenutzerKlasseScalarWhereInput | BenutzerKlasseScalarWhereInput[]
  }

  export type BenutzerFachUpdateManyWithoutBenutzerNestedInput = {
    create?: XOR<BenutzerFachCreateWithoutBenutzerInput, BenutzerFachUncheckedCreateWithoutBenutzerInput> | BenutzerFachCreateWithoutBenutzerInput[] | BenutzerFachUncheckedCreateWithoutBenutzerInput[]
    connectOrCreate?: BenutzerFachCreateOrConnectWithoutBenutzerInput | BenutzerFachCreateOrConnectWithoutBenutzerInput[]
    upsert?: BenutzerFachUpsertWithWhereUniqueWithoutBenutzerInput | BenutzerFachUpsertWithWhereUniqueWithoutBenutzerInput[]
    createMany?: BenutzerFachCreateManyBenutzerInputEnvelope
    set?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    disconnect?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    delete?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    connect?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    update?: BenutzerFachUpdateWithWhereUniqueWithoutBenutzerInput | BenutzerFachUpdateWithWhereUniqueWithoutBenutzerInput[]
    updateMany?: BenutzerFachUpdateManyWithWhereWithoutBenutzerInput | BenutzerFachUpdateManyWithWhereWithoutBenutzerInput[]
    deleteMany?: BenutzerFachScalarWhereInput | BenutzerFachScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BenutzerRolleUncheckedUpdateManyWithoutBenutzerNestedInput = {
    create?: XOR<BenutzerRolleCreateWithoutBenutzerInput, BenutzerRolleUncheckedCreateWithoutBenutzerInput> | BenutzerRolleCreateWithoutBenutzerInput[] | BenutzerRolleUncheckedCreateWithoutBenutzerInput[]
    connectOrCreate?: BenutzerRolleCreateOrConnectWithoutBenutzerInput | BenutzerRolleCreateOrConnectWithoutBenutzerInput[]
    upsert?: BenutzerRolleUpsertWithWhereUniqueWithoutBenutzerInput | BenutzerRolleUpsertWithWhereUniqueWithoutBenutzerInput[]
    createMany?: BenutzerRolleCreateManyBenutzerInputEnvelope
    set?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    disconnect?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    delete?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    connect?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    update?: BenutzerRolleUpdateWithWhereUniqueWithoutBenutzerInput | BenutzerRolleUpdateWithWhereUniqueWithoutBenutzerInput[]
    updateMany?: BenutzerRolleUpdateManyWithWhereWithoutBenutzerInput | BenutzerRolleUpdateManyWithWhereWithoutBenutzerInput[]
    deleteMany?: BenutzerRolleScalarWhereInput | BenutzerRolleScalarWhereInput[]
  }

  export type BenutzerKlasseUncheckedUpdateManyWithoutBenutzerNestedInput = {
    create?: XOR<BenutzerKlasseCreateWithoutBenutzerInput, BenutzerKlasseUncheckedCreateWithoutBenutzerInput> | BenutzerKlasseCreateWithoutBenutzerInput[] | BenutzerKlasseUncheckedCreateWithoutBenutzerInput[]
    connectOrCreate?: BenutzerKlasseCreateOrConnectWithoutBenutzerInput | BenutzerKlasseCreateOrConnectWithoutBenutzerInput[]
    upsert?: BenutzerKlasseUpsertWithWhereUniqueWithoutBenutzerInput | BenutzerKlasseUpsertWithWhereUniqueWithoutBenutzerInput[]
    createMany?: BenutzerKlasseCreateManyBenutzerInputEnvelope
    set?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    disconnect?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    delete?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    connect?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    update?: BenutzerKlasseUpdateWithWhereUniqueWithoutBenutzerInput | BenutzerKlasseUpdateWithWhereUniqueWithoutBenutzerInput[]
    updateMany?: BenutzerKlasseUpdateManyWithWhereWithoutBenutzerInput | BenutzerKlasseUpdateManyWithWhereWithoutBenutzerInput[]
    deleteMany?: BenutzerKlasseScalarWhereInput | BenutzerKlasseScalarWhereInput[]
  }

  export type BenutzerFachUncheckedUpdateManyWithoutBenutzerNestedInput = {
    create?: XOR<BenutzerFachCreateWithoutBenutzerInput, BenutzerFachUncheckedCreateWithoutBenutzerInput> | BenutzerFachCreateWithoutBenutzerInput[] | BenutzerFachUncheckedCreateWithoutBenutzerInput[]
    connectOrCreate?: BenutzerFachCreateOrConnectWithoutBenutzerInput | BenutzerFachCreateOrConnectWithoutBenutzerInput[]
    upsert?: BenutzerFachUpsertWithWhereUniqueWithoutBenutzerInput | BenutzerFachUpsertWithWhereUniqueWithoutBenutzerInput[]
    createMany?: BenutzerFachCreateManyBenutzerInputEnvelope
    set?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    disconnect?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    delete?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    connect?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    update?: BenutzerFachUpdateWithWhereUniqueWithoutBenutzerInput | BenutzerFachUpdateWithWhereUniqueWithoutBenutzerInput[]
    updateMany?: BenutzerFachUpdateManyWithWhereWithoutBenutzerInput | BenutzerFachUpdateManyWithWhereWithoutBenutzerInput[]
    deleteMany?: BenutzerFachScalarWhereInput | BenutzerFachScalarWhereInput[]
  }

  export type BenutzerRolleCreateNestedManyWithoutRolleInput = {
    create?: XOR<BenutzerRolleCreateWithoutRolleInput, BenutzerRolleUncheckedCreateWithoutRolleInput> | BenutzerRolleCreateWithoutRolleInput[] | BenutzerRolleUncheckedCreateWithoutRolleInput[]
    connectOrCreate?: BenutzerRolleCreateOrConnectWithoutRolleInput | BenutzerRolleCreateOrConnectWithoutRolleInput[]
    createMany?: BenutzerRolleCreateManyRolleInputEnvelope
    connect?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
  }

  export type BenutzerRolleUncheckedCreateNestedManyWithoutRolleInput = {
    create?: XOR<BenutzerRolleCreateWithoutRolleInput, BenutzerRolleUncheckedCreateWithoutRolleInput> | BenutzerRolleCreateWithoutRolleInput[] | BenutzerRolleUncheckedCreateWithoutRolleInput[]
    connectOrCreate?: BenutzerRolleCreateOrConnectWithoutRolleInput | BenutzerRolleCreateOrConnectWithoutRolleInput[]
    createMany?: BenutzerRolleCreateManyRolleInputEnvelope
    connect?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BenutzerRolleUpdateManyWithoutRolleNestedInput = {
    create?: XOR<BenutzerRolleCreateWithoutRolleInput, BenutzerRolleUncheckedCreateWithoutRolleInput> | BenutzerRolleCreateWithoutRolleInput[] | BenutzerRolleUncheckedCreateWithoutRolleInput[]
    connectOrCreate?: BenutzerRolleCreateOrConnectWithoutRolleInput | BenutzerRolleCreateOrConnectWithoutRolleInput[]
    upsert?: BenutzerRolleUpsertWithWhereUniqueWithoutRolleInput | BenutzerRolleUpsertWithWhereUniqueWithoutRolleInput[]
    createMany?: BenutzerRolleCreateManyRolleInputEnvelope
    set?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    disconnect?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    delete?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    connect?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    update?: BenutzerRolleUpdateWithWhereUniqueWithoutRolleInput | BenutzerRolleUpdateWithWhereUniqueWithoutRolleInput[]
    updateMany?: BenutzerRolleUpdateManyWithWhereWithoutRolleInput | BenutzerRolleUpdateManyWithWhereWithoutRolleInput[]
    deleteMany?: BenutzerRolleScalarWhereInput | BenutzerRolleScalarWhereInput[]
  }

  export type BenutzerRolleUncheckedUpdateManyWithoutRolleNestedInput = {
    create?: XOR<BenutzerRolleCreateWithoutRolleInput, BenutzerRolleUncheckedCreateWithoutRolleInput> | BenutzerRolleCreateWithoutRolleInput[] | BenutzerRolleUncheckedCreateWithoutRolleInput[]
    connectOrCreate?: BenutzerRolleCreateOrConnectWithoutRolleInput | BenutzerRolleCreateOrConnectWithoutRolleInput[]
    upsert?: BenutzerRolleUpsertWithWhereUniqueWithoutRolleInput | BenutzerRolleUpsertWithWhereUniqueWithoutRolleInput[]
    createMany?: BenutzerRolleCreateManyRolleInputEnvelope
    set?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    disconnect?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    delete?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    connect?: BenutzerRolleWhereUniqueInput | BenutzerRolleWhereUniqueInput[]
    update?: BenutzerRolleUpdateWithWhereUniqueWithoutRolleInput | BenutzerRolleUpdateWithWhereUniqueWithoutRolleInput[]
    updateMany?: BenutzerRolleUpdateManyWithWhereWithoutRolleInput | BenutzerRolleUpdateManyWithWhereWithoutRolleInput[]
    deleteMany?: BenutzerRolleScalarWhereInput | BenutzerRolleScalarWhereInput[]
  }

  export type BenutzerCreateNestedOneWithoutBenutzer_rollenInput = {
    create?: XOR<BenutzerCreateWithoutBenutzer_rollenInput, BenutzerUncheckedCreateWithoutBenutzer_rollenInput>
    connectOrCreate?: BenutzerCreateOrConnectWithoutBenutzer_rollenInput
    connect?: BenutzerWhereUniqueInput
  }

  export type RolleCreateNestedOneWithoutBenutzer_rollenInput = {
    create?: XOR<RolleCreateWithoutBenutzer_rollenInput, RolleUncheckedCreateWithoutBenutzer_rollenInput>
    connectOrCreate?: RolleCreateOrConnectWithoutBenutzer_rollenInput
    connect?: RolleWhereUniqueInput
  }

  export type BenutzerUpdateOneRequiredWithoutBenutzer_rollenNestedInput = {
    create?: XOR<BenutzerCreateWithoutBenutzer_rollenInput, BenutzerUncheckedCreateWithoutBenutzer_rollenInput>
    connectOrCreate?: BenutzerCreateOrConnectWithoutBenutzer_rollenInput
    upsert?: BenutzerUpsertWithoutBenutzer_rollenInput
    connect?: BenutzerWhereUniqueInput
    update?: XOR<XOR<BenutzerUpdateToOneWithWhereWithoutBenutzer_rollenInput, BenutzerUpdateWithoutBenutzer_rollenInput>, BenutzerUncheckedUpdateWithoutBenutzer_rollenInput>
  }

  export type RolleUpdateOneRequiredWithoutBenutzer_rollenNestedInput = {
    create?: XOR<RolleCreateWithoutBenutzer_rollenInput, RolleUncheckedCreateWithoutBenutzer_rollenInput>
    connectOrCreate?: RolleCreateOrConnectWithoutBenutzer_rollenInput
    upsert?: RolleUpsertWithoutBenutzer_rollenInput
    connect?: RolleWhereUniqueInput
    update?: XOR<XOR<RolleUpdateToOneWithWhereWithoutBenutzer_rollenInput, RolleUpdateWithoutBenutzer_rollenInput>, RolleUncheckedUpdateWithoutBenutzer_rollenInput>
  }

  export type BenutzerKlasseCreateNestedManyWithoutKlasseInput = {
    create?: XOR<BenutzerKlasseCreateWithoutKlasseInput, BenutzerKlasseUncheckedCreateWithoutKlasseInput> | BenutzerKlasseCreateWithoutKlasseInput[] | BenutzerKlasseUncheckedCreateWithoutKlasseInput[]
    connectOrCreate?: BenutzerKlasseCreateOrConnectWithoutKlasseInput | BenutzerKlasseCreateOrConnectWithoutKlasseInput[]
    createMany?: BenutzerKlasseCreateManyKlasseInputEnvelope
    connect?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
  }

  export type BenutzerKlasseUncheckedCreateNestedManyWithoutKlasseInput = {
    create?: XOR<BenutzerKlasseCreateWithoutKlasseInput, BenutzerKlasseUncheckedCreateWithoutKlasseInput> | BenutzerKlasseCreateWithoutKlasseInput[] | BenutzerKlasseUncheckedCreateWithoutKlasseInput[]
    connectOrCreate?: BenutzerKlasseCreateOrConnectWithoutKlasseInput | BenutzerKlasseCreateOrConnectWithoutKlasseInput[]
    createMany?: BenutzerKlasseCreateManyKlasseInputEnvelope
    connect?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
  }

  export type BenutzerKlasseUpdateManyWithoutKlasseNestedInput = {
    create?: XOR<BenutzerKlasseCreateWithoutKlasseInput, BenutzerKlasseUncheckedCreateWithoutKlasseInput> | BenutzerKlasseCreateWithoutKlasseInput[] | BenutzerKlasseUncheckedCreateWithoutKlasseInput[]
    connectOrCreate?: BenutzerKlasseCreateOrConnectWithoutKlasseInput | BenutzerKlasseCreateOrConnectWithoutKlasseInput[]
    upsert?: BenutzerKlasseUpsertWithWhereUniqueWithoutKlasseInput | BenutzerKlasseUpsertWithWhereUniqueWithoutKlasseInput[]
    createMany?: BenutzerKlasseCreateManyKlasseInputEnvelope
    set?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    disconnect?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    delete?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    connect?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    update?: BenutzerKlasseUpdateWithWhereUniqueWithoutKlasseInput | BenutzerKlasseUpdateWithWhereUniqueWithoutKlasseInput[]
    updateMany?: BenutzerKlasseUpdateManyWithWhereWithoutKlasseInput | BenutzerKlasseUpdateManyWithWhereWithoutKlasseInput[]
    deleteMany?: BenutzerKlasseScalarWhereInput | BenutzerKlasseScalarWhereInput[]
  }

  export type BenutzerKlasseUncheckedUpdateManyWithoutKlasseNestedInput = {
    create?: XOR<BenutzerKlasseCreateWithoutKlasseInput, BenutzerKlasseUncheckedCreateWithoutKlasseInput> | BenutzerKlasseCreateWithoutKlasseInput[] | BenutzerKlasseUncheckedCreateWithoutKlasseInput[]
    connectOrCreate?: BenutzerKlasseCreateOrConnectWithoutKlasseInput | BenutzerKlasseCreateOrConnectWithoutKlasseInput[]
    upsert?: BenutzerKlasseUpsertWithWhereUniqueWithoutKlasseInput | BenutzerKlasseUpsertWithWhereUniqueWithoutKlasseInput[]
    createMany?: BenutzerKlasseCreateManyKlasseInputEnvelope
    set?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    disconnect?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    delete?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    connect?: BenutzerKlasseWhereUniqueInput | BenutzerKlasseWhereUniqueInput[]
    update?: BenutzerKlasseUpdateWithWhereUniqueWithoutKlasseInput | BenutzerKlasseUpdateWithWhereUniqueWithoutKlasseInput[]
    updateMany?: BenutzerKlasseUpdateManyWithWhereWithoutKlasseInput | BenutzerKlasseUpdateManyWithWhereWithoutKlasseInput[]
    deleteMany?: BenutzerKlasseScalarWhereInput | BenutzerKlasseScalarWhereInput[]
  }

  export type KlasseCreateNestedOneWithoutBenutzer_klassenInput = {
    create?: XOR<KlasseCreateWithoutBenutzer_klassenInput, KlasseUncheckedCreateWithoutBenutzer_klassenInput>
    connectOrCreate?: KlasseCreateOrConnectWithoutBenutzer_klassenInput
    connect?: KlasseWhereUniqueInput
  }

  export type BenutzerCreateNestedOneWithoutBenutzer_klassenInput = {
    create?: XOR<BenutzerCreateWithoutBenutzer_klassenInput, BenutzerUncheckedCreateWithoutBenutzer_klassenInput>
    connectOrCreate?: BenutzerCreateOrConnectWithoutBenutzer_klassenInput
    connect?: BenutzerWhereUniqueInput
  }

  export type KlasseUpdateOneRequiredWithoutBenutzer_klassenNestedInput = {
    create?: XOR<KlasseCreateWithoutBenutzer_klassenInput, KlasseUncheckedCreateWithoutBenutzer_klassenInput>
    connectOrCreate?: KlasseCreateOrConnectWithoutBenutzer_klassenInput
    upsert?: KlasseUpsertWithoutBenutzer_klassenInput
    connect?: KlasseWhereUniqueInput
    update?: XOR<XOR<KlasseUpdateToOneWithWhereWithoutBenutzer_klassenInput, KlasseUpdateWithoutBenutzer_klassenInput>, KlasseUncheckedUpdateWithoutBenutzer_klassenInput>
  }

  export type BenutzerUpdateOneRequiredWithoutBenutzer_klassenNestedInput = {
    create?: XOR<BenutzerCreateWithoutBenutzer_klassenInput, BenutzerUncheckedCreateWithoutBenutzer_klassenInput>
    connectOrCreate?: BenutzerCreateOrConnectWithoutBenutzer_klassenInput
    upsert?: BenutzerUpsertWithoutBenutzer_klassenInput
    connect?: BenutzerWhereUniqueInput
    update?: XOR<XOR<BenutzerUpdateToOneWithWhereWithoutBenutzer_klassenInput, BenutzerUpdateWithoutBenutzer_klassenInput>, BenutzerUncheckedUpdateWithoutBenutzer_klassenInput>
  }

  export type BenutzerFachCreateNestedManyWithoutFachInput = {
    create?: XOR<BenutzerFachCreateWithoutFachInput, BenutzerFachUncheckedCreateWithoutFachInput> | BenutzerFachCreateWithoutFachInput[] | BenutzerFachUncheckedCreateWithoutFachInput[]
    connectOrCreate?: BenutzerFachCreateOrConnectWithoutFachInput | BenutzerFachCreateOrConnectWithoutFachInput[]
    createMany?: BenutzerFachCreateManyFachInputEnvelope
    connect?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
  }

  export type BenutzerFachUncheckedCreateNestedManyWithoutFachInput = {
    create?: XOR<BenutzerFachCreateWithoutFachInput, BenutzerFachUncheckedCreateWithoutFachInput> | BenutzerFachCreateWithoutFachInput[] | BenutzerFachUncheckedCreateWithoutFachInput[]
    connectOrCreate?: BenutzerFachCreateOrConnectWithoutFachInput | BenutzerFachCreateOrConnectWithoutFachInput[]
    createMany?: BenutzerFachCreateManyFachInputEnvelope
    connect?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
  }

  export type BenutzerFachUpdateManyWithoutFachNestedInput = {
    create?: XOR<BenutzerFachCreateWithoutFachInput, BenutzerFachUncheckedCreateWithoutFachInput> | BenutzerFachCreateWithoutFachInput[] | BenutzerFachUncheckedCreateWithoutFachInput[]
    connectOrCreate?: BenutzerFachCreateOrConnectWithoutFachInput | BenutzerFachCreateOrConnectWithoutFachInput[]
    upsert?: BenutzerFachUpsertWithWhereUniqueWithoutFachInput | BenutzerFachUpsertWithWhereUniqueWithoutFachInput[]
    createMany?: BenutzerFachCreateManyFachInputEnvelope
    set?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    disconnect?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    delete?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    connect?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    update?: BenutzerFachUpdateWithWhereUniqueWithoutFachInput | BenutzerFachUpdateWithWhereUniqueWithoutFachInput[]
    updateMany?: BenutzerFachUpdateManyWithWhereWithoutFachInput | BenutzerFachUpdateManyWithWhereWithoutFachInput[]
    deleteMany?: BenutzerFachScalarWhereInput | BenutzerFachScalarWhereInput[]
  }

  export type BenutzerFachUncheckedUpdateManyWithoutFachNestedInput = {
    create?: XOR<BenutzerFachCreateWithoutFachInput, BenutzerFachUncheckedCreateWithoutFachInput> | BenutzerFachCreateWithoutFachInput[] | BenutzerFachUncheckedCreateWithoutFachInput[]
    connectOrCreate?: BenutzerFachCreateOrConnectWithoutFachInput | BenutzerFachCreateOrConnectWithoutFachInput[]
    upsert?: BenutzerFachUpsertWithWhereUniqueWithoutFachInput | BenutzerFachUpsertWithWhereUniqueWithoutFachInput[]
    createMany?: BenutzerFachCreateManyFachInputEnvelope
    set?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    disconnect?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    delete?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    connect?: BenutzerFachWhereUniqueInput | BenutzerFachWhereUniqueInput[]
    update?: BenutzerFachUpdateWithWhereUniqueWithoutFachInput | BenutzerFachUpdateWithWhereUniqueWithoutFachInput[]
    updateMany?: BenutzerFachUpdateManyWithWhereWithoutFachInput | BenutzerFachUpdateManyWithWhereWithoutFachInput[]
    deleteMany?: BenutzerFachScalarWhereInput | BenutzerFachScalarWhereInput[]
  }

  export type BenutzerCreateNestedOneWithoutBenutzer_faecherInput = {
    create?: XOR<BenutzerCreateWithoutBenutzer_faecherInput, BenutzerUncheckedCreateWithoutBenutzer_faecherInput>
    connectOrCreate?: BenutzerCreateOrConnectWithoutBenutzer_faecherInput
    connect?: BenutzerWhereUniqueInput
  }

  export type FachCreateNestedOneWithoutBenutzer_faecherInput = {
    create?: XOR<FachCreateWithoutBenutzer_faecherInput, FachUncheckedCreateWithoutBenutzer_faecherInput>
    connectOrCreate?: FachCreateOrConnectWithoutBenutzer_faecherInput
    connect?: FachWhereUniqueInput
  }

  export type BenutzerUpdateOneRequiredWithoutBenutzer_faecherNestedInput = {
    create?: XOR<BenutzerCreateWithoutBenutzer_faecherInput, BenutzerUncheckedCreateWithoutBenutzer_faecherInput>
    connectOrCreate?: BenutzerCreateOrConnectWithoutBenutzer_faecherInput
    upsert?: BenutzerUpsertWithoutBenutzer_faecherInput
    connect?: BenutzerWhereUniqueInput
    update?: XOR<XOR<BenutzerUpdateToOneWithWhereWithoutBenutzer_faecherInput, BenutzerUpdateWithoutBenutzer_faecherInput>, BenutzerUncheckedUpdateWithoutBenutzer_faecherInput>
  }

  export type FachUpdateOneRequiredWithoutBenutzer_faecherNestedInput = {
    create?: XOR<FachCreateWithoutBenutzer_faecherInput, FachUncheckedCreateWithoutBenutzer_faecherInput>
    connectOrCreate?: FachCreateOrConnectWithoutBenutzer_faecherInput
    upsert?: FachUpsertWithoutBenutzer_faecherInput
    connect?: FachWhereUniqueInput
    update?: XOR<XOR<FachUpdateToOneWithWhereWithoutBenutzer_faecherInput, FachUpdateWithoutBenutzer_faecherInput>, FachUncheckedUpdateWithoutBenutzer_faecherInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BenutzerRolleCreateWithoutBenutzerInput = {
    rolle: RolleCreateNestedOneWithoutBenutzer_rollenInput
  }

  export type BenutzerRolleUncheckedCreateWithoutBenutzerInput = {
    id?: number
    rolle_id: number
  }

  export type BenutzerRolleCreateOrConnectWithoutBenutzerInput = {
    where: BenutzerRolleWhereUniqueInput
    create: XOR<BenutzerRolleCreateWithoutBenutzerInput, BenutzerRolleUncheckedCreateWithoutBenutzerInput>
  }

  export type BenutzerRolleCreateManyBenutzerInputEnvelope = {
    data: BenutzerRolleCreateManyBenutzerInput | BenutzerRolleCreateManyBenutzerInput[]
    skipDuplicates?: boolean
  }

  export type BenutzerKlasseCreateWithoutBenutzerInput = {
    klasse: KlasseCreateNestedOneWithoutBenutzer_klassenInput
  }

  export type BenutzerKlasseUncheckedCreateWithoutBenutzerInput = {
    id?: number
    klasse_id: number
  }

  export type BenutzerKlasseCreateOrConnectWithoutBenutzerInput = {
    where: BenutzerKlasseWhereUniqueInput
    create: XOR<BenutzerKlasseCreateWithoutBenutzerInput, BenutzerKlasseUncheckedCreateWithoutBenutzerInput>
  }

  export type BenutzerKlasseCreateManyBenutzerInputEnvelope = {
    data: BenutzerKlasseCreateManyBenutzerInput | BenutzerKlasseCreateManyBenutzerInput[]
    skipDuplicates?: boolean
  }

  export type BenutzerFachCreateWithoutBenutzerInput = {
    fach: FachCreateNestedOneWithoutBenutzer_faecherInput
  }

  export type BenutzerFachUncheckedCreateWithoutBenutzerInput = {
    id?: number
    fach_id: number
  }

  export type BenutzerFachCreateOrConnectWithoutBenutzerInput = {
    where: BenutzerFachWhereUniqueInput
    create: XOR<BenutzerFachCreateWithoutBenutzerInput, BenutzerFachUncheckedCreateWithoutBenutzerInput>
  }

  export type BenutzerFachCreateManyBenutzerInputEnvelope = {
    data: BenutzerFachCreateManyBenutzerInput | BenutzerFachCreateManyBenutzerInput[]
    skipDuplicates?: boolean
  }

  export type BenutzerRolleUpsertWithWhereUniqueWithoutBenutzerInput = {
    where: BenutzerRolleWhereUniqueInput
    update: XOR<BenutzerRolleUpdateWithoutBenutzerInput, BenutzerRolleUncheckedUpdateWithoutBenutzerInput>
    create: XOR<BenutzerRolleCreateWithoutBenutzerInput, BenutzerRolleUncheckedCreateWithoutBenutzerInput>
  }

  export type BenutzerRolleUpdateWithWhereUniqueWithoutBenutzerInput = {
    where: BenutzerRolleWhereUniqueInput
    data: XOR<BenutzerRolleUpdateWithoutBenutzerInput, BenutzerRolleUncheckedUpdateWithoutBenutzerInput>
  }

  export type BenutzerRolleUpdateManyWithWhereWithoutBenutzerInput = {
    where: BenutzerRolleScalarWhereInput
    data: XOR<BenutzerRolleUpdateManyMutationInput, BenutzerRolleUncheckedUpdateManyWithoutBenutzerInput>
  }

  export type BenutzerRolleScalarWhereInput = {
    AND?: BenutzerRolleScalarWhereInput | BenutzerRolleScalarWhereInput[]
    OR?: BenutzerRolleScalarWhereInput[]
    NOT?: BenutzerRolleScalarWhereInput | BenutzerRolleScalarWhereInput[]
    id?: IntFilter<"BenutzerRolle"> | number
    benutzer_id?: IntFilter<"BenutzerRolle"> | number
    rolle_id?: IntFilter<"BenutzerRolle"> | number
  }

  export type BenutzerKlasseUpsertWithWhereUniqueWithoutBenutzerInput = {
    where: BenutzerKlasseWhereUniqueInput
    update: XOR<BenutzerKlasseUpdateWithoutBenutzerInput, BenutzerKlasseUncheckedUpdateWithoutBenutzerInput>
    create: XOR<BenutzerKlasseCreateWithoutBenutzerInput, BenutzerKlasseUncheckedCreateWithoutBenutzerInput>
  }

  export type BenutzerKlasseUpdateWithWhereUniqueWithoutBenutzerInput = {
    where: BenutzerKlasseWhereUniqueInput
    data: XOR<BenutzerKlasseUpdateWithoutBenutzerInput, BenutzerKlasseUncheckedUpdateWithoutBenutzerInput>
  }

  export type BenutzerKlasseUpdateManyWithWhereWithoutBenutzerInput = {
    where: BenutzerKlasseScalarWhereInput
    data: XOR<BenutzerKlasseUpdateManyMutationInput, BenutzerKlasseUncheckedUpdateManyWithoutBenutzerInput>
  }

  export type BenutzerKlasseScalarWhereInput = {
    AND?: BenutzerKlasseScalarWhereInput | BenutzerKlasseScalarWhereInput[]
    OR?: BenutzerKlasseScalarWhereInput[]
    NOT?: BenutzerKlasseScalarWhereInput | BenutzerKlasseScalarWhereInput[]
    id?: IntFilter<"BenutzerKlasse"> | number
    benutzer_id?: IntFilter<"BenutzerKlasse"> | number
    klasse_id?: IntFilter<"BenutzerKlasse"> | number
  }

  export type BenutzerFachUpsertWithWhereUniqueWithoutBenutzerInput = {
    where: BenutzerFachWhereUniqueInput
    update: XOR<BenutzerFachUpdateWithoutBenutzerInput, BenutzerFachUncheckedUpdateWithoutBenutzerInput>
    create: XOR<BenutzerFachCreateWithoutBenutzerInput, BenutzerFachUncheckedCreateWithoutBenutzerInput>
  }

  export type BenutzerFachUpdateWithWhereUniqueWithoutBenutzerInput = {
    where: BenutzerFachWhereUniqueInput
    data: XOR<BenutzerFachUpdateWithoutBenutzerInput, BenutzerFachUncheckedUpdateWithoutBenutzerInput>
  }

  export type BenutzerFachUpdateManyWithWhereWithoutBenutzerInput = {
    where: BenutzerFachScalarWhereInput
    data: XOR<BenutzerFachUpdateManyMutationInput, BenutzerFachUncheckedUpdateManyWithoutBenutzerInput>
  }

  export type BenutzerFachScalarWhereInput = {
    AND?: BenutzerFachScalarWhereInput | BenutzerFachScalarWhereInput[]
    OR?: BenutzerFachScalarWhereInput[]
    NOT?: BenutzerFachScalarWhereInput | BenutzerFachScalarWhereInput[]
    id?: IntFilter<"BenutzerFach"> | number
    benutzer_id?: IntFilter<"BenutzerFach"> | number
    fach_id?: IntFilter<"BenutzerFach"> | number
  }

  export type BenutzerRolleCreateWithoutRolleInput = {
    benutzer: BenutzerCreateNestedOneWithoutBenutzer_rollenInput
  }

  export type BenutzerRolleUncheckedCreateWithoutRolleInput = {
    id?: number
    benutzer_id: number
  }

  export type BenutzerRolleCreateOrConnectWithoutRolleInput = {
    where: BenutzerRolleWhereUniqueInput
    create: XOR<BenutzerRolleCreateWithoutRolleInput, BenutzerRolleUncheckedCreateWithoutRolleInput>
  }

  export type BenutzerRolleCreateManyRolleInputEnvelope = {
    data: BenutzerRolleCreateManyRolleInput | BenutzerRolleCreateManyRolleInput[]
    skipDuplicates?: boolean
  }

  export type BenutzerRolleUpsertWithWhereUniqueWithoutRolleInput = {
    where: BenutzerRolleWhereUniqueInput
    update: XOR<BenutzerRolleUpdateWithoutRolleInput, BenutzerRolleUncheckedUpdateWithoutRolleInput>
    create: XOR<BenutzerRolleCreateWithoutRolleInput, BenutzerRolleUncheckedCreateWithoutRolleInput>
  }

  export type BenutzerRolleUpdateWithWhereUniqueWithoutRolleInput = {
    where: BenutzerRolleWhereUniqueInput
    data: XOR<BenutzerRolleUpdateWithoutRolleInput, BenutzerRolleUncheckedUpdateWithoutRolleInput>
  }

  export type BenutzerRolleUpdateManyWithWhereWithoutRolleInput = {
    where: BenutzerRolleScalarWhereInput
    data: XOR<BenutzerRolleUpdateManyMutationInput, BenutzerRolleUncheckedUpdateManyWithoutRolleInput>
  }

  export type BenutzerCreateWithoutBenutzer_rollenInput = {
    vorname: string
    nachname: string
    email: string
    passwort_hash: string
    erstellt_am?: Date | string
    aktiv?: boolean
    benutzer_klassen?: BenutzerKlasseCreateNestedManyWithoutBenutzerInput
    benutzer_faecher?: BenutzerFachCreateNestedManyWithoutBenutzerInput
  }

  export type BenutzerUncheckedCreateWithoutBenutzer_rollenInput = {
    id?: number
    vorname: string
    nachname: string
    email: string
    passwort_hash: string
    erstellt_am?: Date | string
    aktiv?: boolean
    benutzer_klassen?: BenutzerKlasseUncheckedCreateNestedManyWithoutBenutzerInput
    benutzer_faecher?: BenutzerFachUncheckedCreateNestedManyWithoutBenutzerInput
  }

  export type BenutzerCreateOrConnectWithoutBenutzer_rollenInput = {
    where: BenutzerWhereUniqueInput
    create: XOR<BenutzerCreateWithoutBenutzer_rollenInput, BenutzerUncheckedCreateWithoutBenutzer_rollenInput>
  }

  export type RolleCreateWithoutBenutzer_rollenInput = {
    bezeichnung: string
    beschreibung?: string | null
  }

  export type RolleUncheckedCreateWithoutBenutzer_rollenInput = {
    id?: number
    bezeichnung: string
    beschreibung?: string | null
  }

  export type RolleCreateOrConnectWithoutBenutzer_rollenInput = {
    where: RolleWhereUniqueInput
    create: XOR<RolleCreateWithoutBenutzer_rollenInput, RolleUncheckedCreateWithoutBenutzer_rollenInput>
  }

  export type BenutzerUpsertWithoutBenutzer_rollenInput = {
    update: XOR<BenutzerUpdateWithoutBenutzer_rollenInput, BenutzerUncheckedUpdateWithoutBenutzer_rollenInput>
    create: XOR<BenutzerCreateWithoutBenutzer_rollenInput, BenutzerUncheckedCreateWithoutBenutzer_rollenInput>
    where?: BenutzerWhereInput
  }

  export type BenutzerUpdateToOneWithWhereWithoutBenutzer_rollenInput = {
    where?: BenutzerWhereInput
    data: XOR<BenutzerUpdateWithoutBenutzer_rollenInput, BenutzerUncheckedUpdateWithoutBenutzer_rollenInput>
  }

  export type BenutzerUpdateWithoutBenutzer_rollenInput = {
    vorname?: StringFieldUpdateOperationsInput | string
    nachname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwort_hash?: StringFieldUpdateOperationsInput | string
    erstellt_am?: DateTimeFieldUpdateOperationsInput | Date | string
    aktiv?: BoolFieldUpdateOperationsInput | boolean
    benutzer_klassen?: BenutzerKlasseUpdateManyWithoutBenutzerNestedInput
    benutzer_faecher?: BenutzerFachUpdateManyWithoutBenutzerNestedInput
  }

  export type BenutzerUncheckedUpdateWithoutBenutzer_rollenInput = {
    id?: IntFieldUpdateOperationsInput | number
    vorname?: StringFieldUpdateOperationsInput | string
    nachname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwort_hash?: StringFieldUpdateOperationsInput | string
    erstellt_am?: DateTimeFieldUpdateOperationsInput | Date | string
    aktiv?: BoolFieldUpdateOperationsInput | boolean
    benutzer_klassen?: BenutzerKlasseUncheckedUpdateManyWithoutBenutzerNestedInput
    benutzer_faecher?: BenutzerFachUncheckedUpdateManyWithoutBenutzerNestedInput
  }

  export type RolleUpsertWithoutBenutzer_rollenInput = {
    update: XOR<RolleUpdateWithoutBenutzer_rollenInput, RolleUncheckedUpdateWithoutBenutzer_rollenInput>
    create: XOR<RolleCreateWithoutBenutzer_rollenInput, RolleUncheckedCreateWithoutBenutzer_rollenInput>
    where?: RolleWhereInput
  }

  export type RolleUpdateToOneWithWhereWithoutBenutzer_rollenInput = {
    where?: RolleWhereInput
    data: XOR<RolleUpdateWithoutBenutzer_rollenInput, RolleUncheckedUpdateWithoutBenutzer_rollenInput>
  }

  export type RolleUpdateWithoutBenutzer_rollenInput = {
    bezeichnung?: StringFieldUpdateOperationsInput | string
    beschreibung?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolleUncheckedUpdateWithoutBenutzer_rollenInput = {
    id?: IntFieldUpdateOperationsInput | number
    bezeichnung?: StringFieldUpdateOperationsInput | string
    beschreibung?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BenutzerKlasseCreateWithoutKlasseInput = {
    benutzer: BenutzerCreateNestedOneWithoutBenutzer_klassenInput
  }

  export type BenutzerKlasseUncheckedCreateWithoutKlasseInput = {
    id?: number
    benutzer_id: number
  }

  export type BenutzerKlasseCreateOrConnectWithoutKlasseInput = {
    where: BenutzerKlasseWhereUniqueInput
    create: XOR<BenutzerKlasseCreateWithoutKlasseInput, BenutzerKlasseUncheckedCreateWithoutKlasseInput>
  }

  export type BenutzerKlasseCreateManyKlasseInputEnvelope = {
    data: BenutzerKlasseCreateManyKlasseInput | BenutzerKlasseCreateManyKlasseInput[]
    skipDuplicates?: boolean
  }

  export type BenutzerKlasseUpsertWithWhereUniqueWithoutKlasseInput = {
    where: BenutzerKlasseWhereUniqueInput
    update: XOR<BenutzerKlasseUpdateWithoutKlasseInput, BenutzerKlasseUncheckedUpdateWithoutKlasseInput>
    create: XOR<BenutzerKlasseCreateWithoutKlasseInput, BenutzerKlasseUncheckedCreateWithoutKlasseInput>
  }

  export type BenutzerKlasseUpdateWithWhereUniqueWithoutKlasseInput = {
    where: BenutzerKlasseWhereUniqueInput
    data: XOR<BenutzerKlasseUpdateWithoutKlasseInput, BenutzerKlasseUncheckedUpdateWithoutKlasseInput>
  }

  export type BenutzerKlasseUpdateManyWithWhereWithoutKlasseInput = {
    where: BenutzerKlasseScalarWhereInput
    data: XOR<BenutzerKlasseUpdateManyMutationInput, BenutzerKlasseUncheckedUpdateManyWithoutKlasseInput>
  }

  export type KlasseCreateWithoutBenutzer_klassenInput = {
    name: string
    jahrgang: number
  }

  export type KlasseUncheckedCreateWithoutBenutzer_klassenInput = {
    id?: number
    name: string
    jahrgang: number
  }

  export type KlasseCreateOrConnectWithoutBenutzer_klassenInput = {
    where: KlasseWhereUniqueInput
    create: XOR<KlasseCreateWithoutBenutzer_klassenInput, KlasseUncheckedCreateWithoutBenutzer_klassenInput>
  }

  export type BenutzerCreateWithoutBenutzer_klassenInput = {
    vorname: string
    nachname: string
    email: string
    passwort_hash: string
    erstellt_am?: Date | string
    aktiv?: boolean
    benutzer_rollen?: BenutzerRolleCreateNestedManyWithoutBenutzerInput
    benutzer_faecher?: BenutzerFachCreateNestedManyWithoutBenutzerInput
  }

  export type BenutzerUncheckedCreateWithoutBenutzer_klassenInput = {
    id?: number
    vorname: string
    nachname: string
    email: string
    passwort_hash: string
    erstellt_am?: Date | string
    aktiv?: boolean
    benutzer_rollen?: BenutzerRolleUncheckedCreateNestedManyWithoutBenutzerInput
    benutzer_faecher?: BenutzerFachUncheckedCreateNestedManyWithoutBenutzerInput
  }

  export type BenutzerCreateOrConnectWithoutBenutzer_klassenInput = {
    where: BenutzerWhereUniqueInput
    create: XOR<BenutzerCreateWithoutBenutzer_klassenInput, BenutzerUncheckedCreateWithoutBenutzer_klassenInput>
  }

  export type KlasseUpsertWithoutBenutzer_klassenInput = {
    update: XOR<KlasseUpdateWithoutBenutzer_klassenInput, KlasseUncheckedUpdateWithoutBenutzer_klassenInput>
    create: XOR<KlasseCreateWithoutBenutzer_klassenInput, KlasseUncheckedCreateWithoutBenutzer_klassenInput>
    where?: KlasseWhereInput
  }

  export type KlasseUpdateToOneWithWhereWithoutBenutzer_klassenInput = {
    where?: KlasseWhereInput
    data: XOR<KlasseUpdateWithoutBenutzer_klassenInput, KlasseUncheckedUpdateWithoutBenutzer_klassenInput>
  }

  export type KlasseUpdateWithoutBenutzer_klassenInput = {
    name?: StringFieldUpdateOperationsInput | string
    jahrgang?: IntFieldUpdateOperationsInput | number
  }

  export type KlasseUncheckedUpdateWithoutBenutzer_klassenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    jahrgang?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerUpsertWithoutBenutzer_klassenInput = {
    update: XOR<BenutzerUpdateWithoutBenutzer_klassenInput, BenutzerUncheckedUpdateWithoutBenutzer_klassenInput>
    create: XOR<BenutzerCreateWithoutBenutzer_klassenInput, BenutzerUncheckedCreateWithoutBenutzer_klassenInput>
    where?: BenutzerWhereInput
  }

  export type BenutzerUpdateToOneWithWhereWithoutBenutzer_klassenInput = {
    where?: BenutzerWhereInput
    data: XOR<BenutzerUpdateWithoutBenutzer_klassenInput, BenutzerUncheckedUpdateWithoutBenutzer_klassenInput>
  }

  export type BenutzerUpdateWithoutBenutzer_klassenInput = {
    vorname?: StringFieldUpdateOperationsInput | string
    nachname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwort_hash?: StringFieldUpdateOperationsInput | string
    erstellt_am?: DateTimeFieldUpdateOperationsInput | Date | string
    aktiv?: BoolFieldUpdateOperationsInput | boolean
    benutzer_rollen?: BenutzerRolleUpdateManyWithoutBenutzerNestedInput
    benutzer_faecher?: BenutzerFachUpdateManyWithoutBenutzerNestedInput
  }

  export type BenutzerUncheckedUpdateWithoutBenutzer_klassenInput = {
    id?: IntFieldUpdateOperationsInput | number
    vorname?: StringFieldUpdateOperationsInput | string
    nachname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwort_hash?: StringFieldUpdateOperationsInput | string
    erstellt_am?: DateTimeFieldUpdateOperationsInput | Date | string
    aktiv?: BoolFieldUpdateOperationsInput | boolean
    benutzer_rollen?: BenutzerRolleUncheckedUpdateManyWithoutBenutzerNestedInput
    benutzer_faecher?: BenutzerFachUncheckedUpdateManyWithoutBenutzerNestedInput
  }

  export type BenutzerFachCreateWithoutFachInput = {
    benutzer: BenutzerCreateNestedOneWithoutBenutzer_faecherInput
  }

  export type BenutzerFachUncheckedCreateWithoutFachInput = {
    id?: number
    benutzer_id: number
  }

  export type BenutzerFachCreateOrConnectWithoutFachInput = {
    where: BenutzerFachWhereUniqueInput
    create: XOR<BenutzerFachCreateWithoutFachInput, BenutzerFachUncheckedCreateWithoutFachInput>
  }

  export type BenutzerFachCreateManyFachInputEnvelope = {
    data: BenutzerFachCreateManyFachInput | BenutzerFachCreateManyFachInput[]
    skipDuplicates?: boolean
  }

  export type BenutzerFachUpsertWithWhereUniqueWithoutFachInput = {
    where: BenutzerFachWhereUniqueInput
    update: XOR<BenutzerFachUpdateWithoutFachInput, BenutzerFachUncheckedUpdateWithoutFachInput>
    create: XOR<BenutzerFachCreateWithoutFachInput, BenutzerFachUncheckedCreateWithoutFachInput>
  }

  export type BenutzerFachUpdateWithWhereUniqueWithoutFachInput = {
    where: BenutzerFachWhereUniqueInput
    data: XOR<BenutzerFachUpdateWithoutFachInput, BenutzerFachUncheckedUpdateWithoutFachInput>
  }

  export type BenutzerFachUpdateManyWithWhereWithoutFachInput = {
    where: BenutzerFachScalarWhereInput
    data: XOR<BenutzerFachUpdateManyMutationInput, BenutzerFachUncheckedUpdateManyWithoutFachInput>
  }

  export type BenutzerCreateWithoutBenutzer_faecherInput = {
    vorname: string
    nachname: string
    email: string
    passwort_hash: string
    erstellt_am?: Date | string
    aktiv?: boolean
    benutzer_rollen?: BenutzerRolleCreateNestedManyWithoutBenutzerInput
    benutzer_klassen?: BenutzerKlasseCreateNestedManyWithoutBenutzerInput
  }

  export type BenutzerUncheckedCreateWithoutBenutzer_faecherInput = {
    id?: number
    vorname: string
    nachname: string
    email: string
    passwort_hash: string
    erstellt_am?: Date | string
    aktiv?: boolean
    benutzer_rollen?: BenutzerRolleUncheckedCreateNestedManyWithoutBenutzerInput
    benutzer_klassen?: BenutzerKlasseUncheckedCreateNestedManyWithoutBenutzerInput
  }

  export type BenutzerCreateOrConnectWithoutBenutzer_faecherInput = {
    where: BenutzerWhereUniqueInput
    create: XOR<BenutzerCreateWithoutBenutzer_faecherInput, BenutzerUncheckedCreateWithoutBenutzer_faecherInput>
  }

  export type FachCreateWithoutBenutzer_faecherInput = {
    name: string
    kuerzel: string
  }

  export type FachUncheckedCreateWithoutBenutzer_faecherInput = {
    id?: number
    name: string
    kuerzel: string
  }

  export type FachCreateOrConnectWithoutBenutzer_faecherInput = {
    where: FachWhereUniqueInput
    create: XOR<FachCreateWithoutBenutzer_faecherInput, FachUncheckedCreateWithoutBenutzer_faecherInput>
  }

  export type BenutzerUpsertWithoutBenutzer_faecherInput = {
    update: XOR<BenutzerUpdateWithoutBenutzer_faecherInput, BenutzerUncheckedUpdateWithoutBenutzer_faecherInput>
    create: XOR<BenutzerCreateWithoutBenutzer_faecherInput, BenutzerUncheckedCreateWithoutBenutzer_faecherInput>
    where?: BenutzerWhereInput
  }

  export type BenutzerUpdateToOneWithWhereWithoutBenutzer_faecherInput = {
    where?: BenutzerWhereInput
    data: XOR<BenutzerUpdateWithoutBenutzer_faecherInput, BenutzerUncheckedUpdateWithoutBenutzer_faecherInput>
  }

  export type BenutzerUpdateWithoutBenutzer_faecherInput = {
    vorname?: StringFieldUpdateOperationsInput | string
    nachname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwort_hash?: StringFieldUpdateOperationsInput | string
    erstellt_am?: DateTimeFieldUpdateOperationsInput | Date | string
    aktiv?: BoolFieldUpdateOperationsInput | boolean
    benutzer_rollen?: BenutzerRolleUpdateManyWithoutBenutzerNestedInput
    benutzer_klassen?: BenutzerKlasseUpdateManyWithoutBenutzerNestedInput
  }

  export type BenutzerUncheckedUpdateWithoutBenutzer_faecherInput = {
    id?: IntFieldUpdateOperationsInput | number
    vorname?: StringFieldUpdateOperationsInput | string
    nachname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwort_hash?: StringFieldUpdateOperationsInput | string
    erstellt_am?: DateTimeFieldUpdateOperationsInput | Date | string
    aktiv?: BoolFieldUpdateOperationsInput | boolean
    benutzer_rollen?: BenutzerRolleUncheckedUpdateManyWithoutBenutzerNestedInput
    benutzer_klassen?: BenutzerKlasseUncheckedUpdateManyWithoutBenutzerNestedInput
  }

  export type FachUpsertWithoutBenutzer_faecherInput = {
    update: XOR<FachUpdateWithoutBenutzer_faecherInput, FachUncheckedUpdateWithoutBenutzer_faecherInput>
    create: XOR<FachCreateWithoutBenutzer_faecherInput, FachUncheckedCreateWithoutBenutzer_faecherInput>
    where?: FachWhereInput
  }

  export type FachUpdateToOneWithWhereWithoutBenutzer_faecherInput = {
    where?: FachWhereInput
    data: XOR<FachUpdateWithoutBenutzer_faecherInput, FachUncheckedUpdateWithoutBenutzer_faecherInput>
  }

  export type FachUpdateWithoutBenutzer_faecherInput = {
    name?: StringFieldUpdateOperationsInput | string
    kuerzel?: StringFieldUpdateOperationsInput | string
  }

  export type FachUncheckedUpdateWithoutBenutzer_faecherInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    kuerzel?: StringFieldUpdateOperationsInput | string
  }

  export type BenutzerRolleCreateManyBenutzerInput = {
    id?: number
    rolle_id: number
  }

  export type BenutzerKlasseCreateManyBenutzerInput = {
    id?: number
    klasse_id: number
  }

  export type BenutzerFachCreateManyBenutzerInput = {
    id?: number
    fach_id: number
  }

  export type BenutzerRolleUpdateWithoutBenutzerInput = {
    rolle?: RolleUpdateOneRequiredWithoutBenutzer_rollenNestedInput
  }

  export type BenutzerRolleUncheckedUpdateWithoutBenutzerInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolle_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerRolleUncheckedUpdateManyWithoutBenutzerInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolle_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerKlasseUpdateWithoutBenutzerInput = {
    klasse?: KlasseUpdateOneRequiredWithoutBenutzer_klassenNestedInput
  }

  export type BenutzerKlasseUncheckedUpdateWithoutBenutzerInput = {
    id?: IntFieldUpdateOperationsInput | number
    klasse_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerKlasseUncheckedUpdateManyWithoutBenutzerInput = {
    id?: IntFieldUpdateOperationsInput | number
    klasse_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerFachUpdateWithoutBenutzerInput = {
    fach?: FachUpdateOneRequiredWithoutBenutzer_faecherNestedInput
  }

  export type BenutzerFachUncheckedUpdateWithoutBenutzerInput = {
    id?: IntFieldUpdateOperationsInput | number
    fach_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerFachUncheckedUpdateManyWithoutBenutzerInput = {
    id?: IntFieldUpdateOperationsInput | number
    fach_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerRolleCreateManyRolleInput = {
    id?: number
    benutzer_id: number
  }

  export type BenutzerRolleUpdateWithoutRolleInput = {
    benutzer?: BenutzerUpdateOneRequiredWithoutBenutzer_rollenNestedInput
  }

  export type BenutzerRolleUncheckedUpdateWithoutRolleInput = {
    id?: IntFieldUpdateOperationsInput | number
    benutzer_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerRolleUncheckedUpdateManyWithoutRolleInput = {
    id?: IntFieldUpdateOperationsInput | number
    benutzer_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerKlasseCreateManyKlasseInput = {
    id?: number
    benutzer_id: number
  }

  export type BenutzerKlasseUpdateWithoutKlasseInput = {
    benutzer?: BenutzerUpdateOneRequiredWithoutBenutzer_klassenNestedInput
  }

  export type BenutzerKlasseUncheckedUpdateWithoutKlasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    benutzer_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerKlasseUncheckedUpdateManyWithoutKlasseInput = {
    id?: IntFieldUpdateOperationsInput | number
    benutzer_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerFachCreateManyFachInput = {
    id?: number
    benutzer_id: number
  }

  export type BenutzerFachUpdateWithoutFachInput = {
    benutzer?: BenutzerUpdateOneRequiredWithoutBenutzer_faecherNestedInput
  }

  export type BenutzerFachUncheckedUpdateWithoutFachInput = {
    id?: IntFieldUpdateOperationsInput | number
    benutzer_id?: IntFieldUpdateOperationsInput | number
  }

  export type BenutzerFachUncheckedUpdateManyWithoutFachInput = {
    id?: IntFieldUpdateOperationsInput | number
    benutzer_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}